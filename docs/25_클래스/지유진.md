## 🔖 25장 - 클래스

```
자바스크립트는 프로토타입 기반 객체지향 언어다.
```

### 목차
- [25.1 클래스는 프로토타입의 문법적 설탕인가?](#클래스는-프로토타입의-문법적-설탕인가?)
- [25.2 클래스 정의](#클래스-정의)
- [25.3 클래스 호이스팅](#클래스-호이스팅)
- [25.4 인스턴스 생성](#인스턴스-생성)

## 클래스의 도입

```
프로토타입 기반 객체지향 언어는 클래스가 필요 없는 객체지향 프로그래밍 언어다.
```

> 🔍 ES5에서는 클래스 없이도 생성자 함수와 프로토타입을 통해 객체지향 언어의 상속을 구현할 수 있다.

📌 ES6에서 도입된 클래스는 기존 `프로토타입 기반 객체지향 프로그래밍`보다 자바나 C#과 같은 `클래스 기반 객체지향 프로그래밍`에 익숙한
프로그래머가 더욱 빠르게 학습할 수 있도록 클래스 기반 객체지향 프로그래밍 언어와 매우 흡사한 새로운 객체 생성 메커니즘을 제시한다.

> 그렇다고 ES6의 클래스가 기존의 프로토타입 기반 객체지향 모델을 폐지하고 새롭게 클래스 기반 객체지향 모델을 제공하는 것은 아니다.
> 
> 사실 클래스는 함수이며 기존 프로토타입 기반 패턴을 클래스 기반 패턴처럼 사용할 수 있도록 하는 문법적 설탕이라고 볼 수도 있다.

## 클래스는 프로토타입의 문법적 설탕인가?

> 클래스와 생성자 함수는 모두 프로토타입 기반의 인스턴스를 생성하지만 정확히 동일하게 동작하지는 않는다.
> 
> 생성자 함수와 클래스는 프로토타입 기반의 객체지향을 구현했다는 점에서 매우 유사하다.
> 하지만 클래스는 생성자 함수 기반의 객체 생성보다 견고하고 명료하다.
> 특히 클래스의 extends와 super 키워드는 상속 관계 구현을 더욱 간결하고 명료하게 한다.

📌 클래스를 프로토타입 기반 객체 생성 패턴의 단순한 문법적 설탕이라고 보기보다는 **새로운 객체 생성 메커니즘**으로 보는 것이 좀 더 합당하다.

## 클래스 정의

📌 클래스는 class 키워드를 사용하여 정의한다.

> 💡 클래스 이름은 생성자 함수와 마찬가지로 파스칼 케이스를 사용하는 것이 일반적이다.

```javascript
// 클래스 선언문
class Person {}
```

일반적이지는 않지만 클래스를 표현식으로 정의할 수도 있다.

> 이때 클래스는 함수와 마찬가지로 이름을 가질 수도, 갖지 않을 수도 있다.

```javascript
// 익명 클래스 표현식
const Person = class {};

// 기명 클래스 표현식
const Person = class MyClass {};
```

📎 클래스 몸체에서 정의할 수 있는 메서드
- constructor(생성자)
- 프로토타입 메서드
- 정적 메서드

```javascript
// 클래스 선언문
class Person {
  // 생성자
  constructor(name) {
    // 인스턴스 생성 및 초기화
    this.name = name; // name 프로퍼티는 public하다.
  }
  
  // 프로토타입 메서드
  sayHi() {
    console.log(`Hi! My name is ${this.name}`);
  }
  
  // 정적 메서드
  static sayHello() {
    console.log('Hello!');
  }
}

// 인스턴스 생성
const me = new Person('Lee');

// 인스턴스의 프로퍼티 참조
console.log(me.name); // Lee
// 프로토타입 메서드 호출
me.sayHi(); // Hi! My name is Lee
// 정적 메서드 호출
Person.sayHello();  // Hello
```

## 클래스 호이스팅

```
클래스는 함수로 평가된다.
클래스 선언문으로 정의한 클래스는 함수 선언문과 같이 소스코드 평가 과정, 즉 런타임 이전에 먼저 평가되어 함수 객체를 생성한다.
```

클래스는 클래스 정의 이전에 참조할 수 없다.

```javascript
console.log(Person);
// ReferenceError: Cannot access 'Person' before initialization

class Person {}
```

클래스 선언문은 마치 호이스팅이 발생하지 않는 것처럼 보이나 그렇지 않다.

```javascript
const Person = '';

{
  // 호이스팅이 발생하지 않는다면 ''이 출력되어야 한다.
  console.log(Person);
  // ReferenceError: Cannot access 'Person' before initialization
  
  class Person {}
}
```

📌 클래스 선언문도 변수 선언, 함수 정의와 마찬가지로 호이스팅이 발생한다.

> 단, 클래스는 let, const 키워드로 선언한 변수처럼 호이스팅된다.
> 따라서 클래스 선언문 이전에 일시적 사각지대에 빠지기 때문에 호이스팅이 발생하지 않는 것처럼 동작한다.

## 인스턴스 생성

📌 클래스는 생성자 함수이며 new 연산자와 함께 호출되어 인스턴스를 생성한다.

```javascript
class Person {}

// 인스턴스 생성
const me = new Person();
console.log(me);  // Person {}
```

> 함수는 new 연산자의 사용 여부에 따라 일반 함수로 호출되거나 인스턴스 생성을 위한 생성자 함수로 호출되지만
> 클래스는 인스턴스를 생성하는 것이 유일한 존재 이유이므로 반드시 new 연산자와 함께 호출해야 한다.

⚠️ 클래스를 new 연산자 없이 호출하면 타입 에러가 발생된다.


