# 25장 클래스

## 📂 25.1 클래스는 프로토타입의 문법적 설탕인가?

- 자바스크립트는 프로토타입 기반<sup>prototype based</sup> 객체지향언어다.
- 프로토타입 기반 객체지향 언어는 클래스가 필요없는<sup>class free</sup> 객체 지향 프로그래밍이다.
- ES5에서는 클래스 없이도 생성자 함수와 프로토타입을 통해 객체지향 언어의 상속을 구현할 수 있다.

#### 클래스

- ES6에 도입
- 클래스는 함수이며 기존 프로토타입 기반 패턴을 클래스 기반 패터ㅗㄴ처럼 사용할 수 있도록 하는 문법적 설탕<sup>syntactic sugar</sup>이라고 볼 수 있다.
- 단, 클래스와 생성자 함수는 모두 프로토타입 기반의 인스턴스를 생성하지만 동작에 차이가 있다.

#### 클래스와 생성자 함수의 차이점

1. 클래스를 `new` 연산자 없이 호출하면 에러가 발생한다.
   ⇒ 생성자 함수를 `new` 연산자 없이 호출하면 일반 함수로서 호출된다.
2. 클래스는 상속을 지원하는 `extends`와 super 키워드를 제공한다.
   ⇒ 생성자 함수는 `extends`와 super 키워드를 제공하지 않는다.
3. 클래스는 호이스팅이 발생하지 않는 것처럼 동작한다.
   ⇒ 함수 선언문으로 정의된 생성자 함수는 함수 호이스팅이, 함수 표현식으로 정의한 생성자 함수는 변수 호이스팅이 발생한다.
4. 클래스 내의 모든 코드에는 암묵적으로 `strict mode`가 지정되어 실행되며 `strict mode`를 해제할 수 없다.
   ⇒ 생성자 함수는 암묵적으로 `strict mode`가 지정되지 않는다.
5. 클래스의 `constructor`, 프로토타입 메서드, 정적 메서드는 모두 프로퍼티 어트리뷰트 `[[Enumerable]]`의 값이 `false`다.

클래스는 생성자 함수 기반의 객체 생성 박식보다 견고하고 명료하다.
따라서 클래스를 프로토타입 기반 객체 생성 패턴의 단순한 문법적 설탕이라고 보기보다는 **새로운 객체 생성 매커니즘**으로 보는 것이 좀 더 합당하다.

## 📂 25.2 클래스 정의

- `class` 키워드를 사용하여 정의
- 클래스 이름은 파스칼 케이스를 사용하는 것이 일반적

```javascript
//  클래스 선언문
class Person {}
```

- 클래스도 표현식으로 정의할 수 있다.

```javascript
// 익명 클래스 표현식
const Person = class {};

// 기명 클래스 표현식
const Person = class MyClass {};
```

⇒ 클래스를 표현식으로 정의할 수 있다는 것은 클래스가 값으로 사용할 수 있는 **일급 객체**라는 것을 의미

#### 클래스가 일급 객체로서 가지는 특징

- 무명의 리터럴로 생성할 수 있다. 즉, 런타임에 생성이 가능하다.
- 변수나 자료구조(객체, 배열 등)에 저장할 수 있다.
- 함수의 매개변수에게 전달할 수 있다.
- 함수의 반환값으로 사용할 수 있다.

⇒ **클래스는 함수다. 따라서 클래스는 값처럼 사용할 수 있는 일급 객체다.**

- 클래스 몸체에는 0개 이상의 메서드만 정의할 수 있다.
- 클래스 몸체에서 정의할 수 있는 메서드
  - `constructor`(생성자)
  - 프로토타입 메서드
  - 정적 메서드

```javascript
// 클래스 선언문
class Person {
  // 생성자
  constructor(name) {
    // 인스턴스 생성 및 초기화
    this.name = name; // name 프로퍼티는 public하다.
  }

  // 프로토타입 메서드
  sayHi() {
    console.log(`Hi! My name is ${this.name}`);
  }

  // 정적 메서드
  static sayHello() {
    console.log('Hello');
  }
}

// 인스턴스 생성
const me = new Person('Lee');

// 인스턴스의 프로퍼티 참조
console.log(me.name); // Lee
// 프로토타입 메서드 호출
me.sayHi(); // Hi! My name is Lee
// 정적 메서드 호출
Person.sayHello(); // Hello
```

- 클래스와 생성자 함수의 정의 방식은 형태적인 면에서 매우 유사하다.

```javascript
// 위의 클래스 코드와 비교
var Person = (function () {
  // 생성자 함수
  function Person(name) {
    this.name = name;
  }

  // 프로토타입 메서드
  Person.prototype.sayHi = function () {
    console.log('Hi! My name is ' + this.name);
  };

  // 정적 메서드
  Person.sayHello = function () {
    console.log('Hello!');
  };

  // 생성자 함수 반환
  return Person;
})();
```

## 📂 25.3 클래스 호이스팅

#### 클래스 선언문으로 정의한 클래스는 함수 선언문과 같이 소스코드 평가과정, 즉 런타임 이전에 먼저 평가되어 함수 객체를 생성한다.

- 이때 클래스가 평가되어 생성된 함수 객체는 생성자 함수로서 호출할 수 있는 함주, 즉 `constructor`다.
- 생성자 함수로서 호출할 수 있는 함수는 함수 정의가 평가되어 함수 객체를 생성하는 시점에 프로토타입도 더불어 생성된다.
  ⇒ 프로토타입과 생성자 함수는 단독으로 존재할 수 없고 언제나 쌍으로 존재하기 떄문

```javascript
// 클래스 선언문
class Person {}

console.log(typeof Person); // function
```

#### 클래스는 클래스 정의 이전에 참조할 수 없다.

```javascript
console.log(Person);
// ReferenceError: Cannot access 'Person' before initialization

// 클래스 선언문
class Person {}
```

#### 클래스 선언문은 마치 호이스팅이 발생하지 않는 것처럼 보이나 그렇지 않다.

- 클래스 선언문은 `let`, `const` 키워드로 선언한 변수처럼 호이스팅이 발생한다.
- 따라서 클래스 선언문 이전에 **일시적 사각지대<sup>Temporal Dead Zone; TDZ</sup>** 에 빠지기 때문에 호이스팅이 발생하지 않는 것처럼 동작한다.

```javascript
const Person = '';

{
  // 호이스팅이 발생하지 않는다면 ''이 출력되어야 한다.
  console.log(Person);
  // ReferenceError: Cannot access 'Person' before initialization

  // 클래스 선언문
  class Person {}
}
```

⇒ `var`, `let`, `const`, `function`, `fucntion*`, `class` 키워드를 사용하여 선언된 모든 식별자는 호이스팅된다. 모든 선언문은 런타임 이전에 먼저 실행되기 때문

## 📂 25.4 인스턴스 생성

#### 클래스는 생성자 함수이며 `new` 연산자와 함께 호출되어 인스턴스를 생성한다.

```javascript
class Person {}

// 인스턴스 생성
const me = new Person();
console.log(me); // Person {}
```

#### 클래스는 new 연산자와 함께 호출해야 한다.

- 함수 : `new` 연산자의 사용 여부에 따라 일반 함수로 호출되거나 인스턴스 생성을 위한 생성자 함수로 호출
- 클래스 : 인스턴스를 생성하는 것이 유일한 존재 이유이므로 반드시 `new` 연산자와 함께 호출해야 한다.

```javascript
class Person {}

// 클래스를 new 연산자 없이 호출하면 타입 에러 발생
const me = Person();
// TypeError: Class constructor Person cannot be invoked without 'new'
```

#### 기명 클래스 표현식의 클래스 이름을 사용해 인스턴스를 생성하면 에러가 발생한다.

- 클래스 표현식으로 정의된 클래스의 경우 다음 예제와 같이 클래스를 가리키는 식별자(`Person`)를 사용해 인스턴스를 생성하지 않고 기명 클래스 표현식의 클래스 이름(`MyClass`)을 사용해 인스턴스를 생성하면 에러가 발생한다.
- 기명 함수 표현식과 마찬가지로 클래스 표현식에서 사용한 클래스 이름은 외부 코드에서 접근 불가능하다.

```javascript
const Person1 = class MyClass {};

// 함수 표현식과 같이 클래스를 가리키는 식별자로 인스턴스를 생성해야 한다.
const me = new Person1();

// 클래스 이름 MyClass는 클래스 몸체 내부에서만 유효한 식별자
console.log(MyClass); // ReferenceError: MyClass is not defined

const you = new MyClass(); // ReferenceError: MyClass is not defined
```

## 📂 25.5 메서드

- 클래스 몸체에는 0개 이상의 메서드만 정의할 수 있다.
- 클래스 몸체에서 정의할 수 있는 메서드
  - `constructor`(생성자)
  - 프로토타입 메서드
  - 정적 메서드

### `constructor`

- 인스턴스를 생성하고 초기화하기 위한 특수한 메서드
- `constructor`는 이름을 변경할 수 없다.

```javascript
class Person {
  // 생성자
  constructor(name) {
    // 인스턴스 생성 및 초기화
    this.name = name;
  }
}

// 인스턴스 생성
const me = new Person('Lee');
console.log(me);
```

![](https://i.imgur.com/DerDXNx.png)

- `Person` 클래스의 `constructor` 내부에서 `this`에 추가한 name 프로퍼티가 클래스가 생성한 인스턴스의 프로퍼티로 추가됨
  ⇒ `constructor` 내부에서 `this`에 추가한 프로퍼티는 인스턴스 프로퍼티가 된다.
- `constructor`는 메서드로 해석되는 것이 아니라 클래스가 평가되어 생성한 함수 객체 코드의 일부가 된다.
  ⇒ 클래스 정의가 평가되면 `constructor`의 기술된 동작을 하는 함수 객체가 생성됨

#### 생성자 함수와의 차이점

- `constructor`는 클래스 내에 최대 한 개만 존재할 수 있다.
  ⇒ 클래스가 2개 이상의 `constructor`를 포함하면 문법 에러 발생
- `constructor`는 생략할 수 있다.
- `constructor`를 생력한 클래스는 빈 `constructor`에 의해 빈 객체를 생성한다.
- 프로퍼티가 추가되어 초기화된 인스턴스를 생성하려면 `constructor` 내부에서 `this`에 인스턴스 프로퍼티를 추가한다.

  ```javascript
  class Person {
    constructor() {
      // 고정값으로 인스턴스 초기화
      this.name = 'Lee';
      this.address = 'Seoul';
    }
  }

  // 인스턴스 프로퍼티가 추가된다.
  const me = new Person();
  console.log(me); // Person {name = 'Lee', address = 'Seoul'}
  ```

- 인스턴스를 생성할 때 클래스 외부에서 인스턴스 프로퍼티의 초기값을 전달하려면 `constructor`에 매개변수를 선언하고 인스턴스를 생성할 때 초기값을 전달한다.

  ```javascript
  class Person {
    constructor(name, address) {
      // 인수로 인스턴스 초기화
      this.name = name;
      this.address = address;
    }
  }

  // 인수로 초기값을 전달하면 constructor에 전달된다.
  const me = new Person('Lee', 'Seoul');
  console.log(me); // Person {name = 'Lee', address = 'Seoul'}
  ```

  ⇒ `constructor` 내에서 인스턴스의 생성과 동시에 인스턴스 프로퍼티 추가를 통해 인스턴스의 초기화를 실행하므로 인스턴스를 초기화하려면 `constructor`를 생략해서는 안된다.

- `constructor`는 별도의 반환문을 갖지 않아야 한다.
  ⇒ `new` 연산자와 함께 클래스가 호출되면 생성자 함수와 동일하게 암묵적으로 `this`, 즉 인스턴스를 반환하기 때문
- 만약 `this`가 아닌 다른 객체를 명시적으로 반환하면 인스턴스가 반환되지 못하고 `return` 문에 명시된 객체가 반환된다.
  ⇒ 명시적으로 원시값을 반환하면 원시값 반환은 무시되고 암묵적으로 `this`가 반환된다.
- `constructor` 내부에서 명시적으로 `this`가 아닌 다른 값을 반환하는 것은 클래스의 기본 동작을 훼손하므로 `return` 문을 반드시 생략해야 한다.

### 프로토타입 메서드

- 클래스 몸체에서 정의한 메서드는 클래스의 `prototype` 프로퍼티에 메서드를 추가하지 않아도 기본적으로 프로토타입 메서드가 된다.
- 클래스가 생성한 인스턴스는 프로토타입 처인의 일원이 된다.

```javascript
class Person {
  // 생성자
  constructor(name) {
    // 인스턴스 생성 및 초기화
    this.name = name;
  }

  // 프로토타입 메서드
  sayHi() {
    console.log(`Hi! My name is ${this.name}`);
  }
}

const me = new Person('Lee');
me.sayHi(); // Hi! My name is Lee

// me 객체의 프로토타입은 Person.prototype이다.
Object.getPrototypeOf(me) === Person.prototype; // true
me instanceof Person; // true

// Person.prototype의 프로토타입은 Object.prototype 이다.
Object.getPrototypeOf(Person.prototype) === Object.prototype; // true
me instanceof Object; //

// me 객체의 constructor는 Person 클래스다.
me.constructor === Person; // true
```

- 클래스 몸체에서 정의한 메서드는 인스턴스의 프로토타입에 존재하는 프로토타입 메서드가 된다.
- 인스턴스는 프로토타입 메서드를 상석받아 사용할 수 있다.

### 정적<sup>static</sup> 메서드

- 인스턴스를 생성하지 않아도 호출할 수 있는 메서드
- 생성자 함수의 경우 정적 메서드를 생성하기 위해 명시적으로 생성자 함수에 메서드를 추가해야 한다.
- 클래스에서는 메서드에 `static` 키워드를 붙이면 정적 메서드가 된다.

  ```javascript
  class Person {
    // 생성자
    constructor(name) {
      // 인스턴스 생성 및 초기화
      this.name = name;
    }

    // 정적 메서드
    static sayHi() {
      console.log('Hi');
    }
  }
  ```

- 정적 메서드는 클래스에 바인딩된 메서드가 된다. 클래스는 함수 객체로 평가되므로 자신의 프로퍼티/메서드를 소유할 수 있다.
- 정적 메서드는 인스턴스로 호출하지 않고 클래스로 호출한다.
  ```javascript
  // 정적 메서드는 클래스로 호출한다.
  // 정먹 메서드는 프로토타입 메서드처럼 인스턴스로 호출하지 않고 클래스로 호출한다.
  Person.sayHi();
  ```
- 정적 메서드는 인스턴스로 호출할 수 있다. 정적 메서드가 바인딩된 클래스는 인스턴스의 프로토타입 체인 생에 존재하지 않기 때문이다.
  ⇒ 인스턴스의 프로토타입 체인 상에는 클래스가 존재하지 않기 떄문에 인스턴스로 클래스의 메서드를 상속받을 수 없다.
  ```javascript
  const me = new Person('Lee');
  me.sayHi(); //TypeError: me.sayHi is not a function
  ```

### 정적 메서드와 프로토타입 메서드의 차이

1. 정적 메서드와 프로토타입 메서드는 자신이 속해 있는 프로토타입 체인이 다르다.
2. 정적 메서드는 클래스를 호출하고 프로토타입 메서드는 인스턴스로 호출할 듯
3. 정적 메서드는 인스턴스 프로퍼티를 참조할 수 없지만 프로토타입 메서드는 인스턴스 프로퍼티를 참조할 수 있다.

```javascript
class Square {
  constructor(width, height) {
    this.width = width;
    this.height = height;
  }

  // 프로토타입 메서드
  area() {
    return this.width * this.height;
  }
}

const square = new Square(10, 10);
console.log(square.area()); // 100
```

- 정적 메서드는 인스턴스 프로퍼티를 참조하지 않는다.
- 만약 프로퍼티를 참조해야 한다면 프로토타입 메서드를 사용해야 한다.
- 메서드 내부의 this는 메서드를 호출한 객체, 즉 메서드 이름 앞에 마침표(`.`) 연산자 앞에 기술한 객체에 바인딩된다.
- 정적 메서드는 클래스로 호출해야 하므로 정적 메서드 내부의` this`는 인스턴스가 아닌 클래스
  ⇒ 프로토타입 메서드와 정적 메서드 내부의 `this` 바인딩이 다르다.
- 메서드 내부에서 인스턴스 프로퍼티를 참조할 필요가 있다면 this를 사용해야 하며, 이런 경우 프로토타입 메서드로 정의 해야한다.
  ⇒ 매서드 내부에서 인스턴스 프로퍼티를 참조해야할 필요가 없다면 `this를` 사용하지 않게 된다.
- 표준 빌터인 객체 `Math`, `Number`, `JSON`, `Object` 등 다양한 정적 메서드를 가지고 있다.
  ⇒ 이들 정적 메서드는 애플리케이션 전역에서 사용할 유틸리티<sup>utility</sup> 함수다.

### 클래스에서 정의한 메서드의 특징

1. `function` 키워드를 생략한 메서드 축약 표현을 사용한다.
2. 객체 리터럴과 다르게 클래스에 메서드를 정의할 때는 콤마가 필요없다.
3. 암묵적으로 `strict mod`e로 실행된다.
4. `for...in` 문이나 `Object.keys` 메서드 등으로 열거할 수 없다.
   ⇒ 프로퍼티의 열거 가능 여부를 나타내며, 불리언 값을 갖는 프로퍼티 어트리뷰트 `[[Enumerable]]`의 값이 `false`다.
5. 내부 메서드 `[[Construct]]`를 갖지 않는 `non-constructor`다. 따라서 `new` 연산자와 함께 호출할 수 없다.
