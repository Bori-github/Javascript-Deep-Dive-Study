## 4.1 변수란 무엇인가? 왜 필요한가?

`변수`를 사용하기만 했지, 왜 변수라는 것이 만들어 졌을까? 라는 질문에 대해서는 깊게 생각해 본 적이 없던 것 같습니다.

> 값이 저장될 메모리의 주소는 매번 코드를 실행시 마다 변경된다. 이처럼 코드가 실행되기 전에는 값이 저장된 메모리 주소를 알 수가 없어 메모리 주소를 통해 값에 직접 접근하는 것은 올바른 방법이 아니다.

변수는 결국 프로그래밍 언어에서 값을 저장하고 참조하는 메커니즘으로, 값의 위치를 가리키는 `상징적인 이름`.

요약해보자면 `변수`가 생기게 된 계기도 메모리 공간에 대한 사용을 재사용하고자 하는 열망에서 `변수`라는 매커니즘이 생기게 된 것입니다.

## 4.2 식별자

변수 이름을 `식별자`라고도 합니다
식별자는 어떤 값을 구별해서 식별할 수 있는 고유한 이름을 말합니다.

> 식별자라는 용어는 변수 이름에만 국한해서 사용하지 않는다.
> 예를 들어 변수, 함수, 클래스 등의 이름은 모두 식별자다
> 즉, 메모리 상에 존재하는 어떤 값을 식별할 수 있는 이름은 모두 식별자라고 부른다.

## 4.3 변수 선언

변수를 사용하려면 반드시 선언이 필요합니다.
Javascript에서 변수를 사용하려면 `var, let, const`를 사용합니다.

`var`를 지양해야하는 이유는 자바스크립트를 다루면서 많이 들어 봤을 것입니다.

`var`를 지양해야하는 이유

1. 중복 선언이 가능

```javascript
var 변수 = "Hello World";
var 변수 = "Bye World"; // 중복 선언을 해도 SyntaxError 발생 x

let 변수 = "Hello World";
let 변수 = "Bye World"; // SyntaxError: Identifier "변수" has already been declared
```

2. 함수 블록 스코프

```javascript
var 변수 = "global";

if (변수) {
  var 변수 = "local";

  console.log(변수); // local
}

console.log(변수); // local
```

```javascript
var 변수 = "global";

function log() {
  var 변수 = "local";

  console.log(변수);
}

log(); // local
console.log(변수); // global
```

프로그래밍을 하면서 블록 스코프에 익숙한 저희에겐 함수 스코프는 인지하고 코드를 짠다해도 예상치 못한 오류를 발생시킬 수 있는 부분입니다.

위의 코드 예시와 같이 생각치 못한 부분에서 놓칠 수가 있기 때문에 블록 스코프를 가지는 `let, const`를 사용하고 `var`를 지양해야 합니다.

3. 호이스팅

```javascript
console.log(변수); // undefined

var 변수 = "Hello World";

console.log(변수); // Hello World
```

- 호이스팅은 다음 세 가지 단계를 거치게 됩니다.
  1.  선언 : 파싱 과정에서 변수 객체가 변수에 대한 식별자들을 수집한다.
  2.  초기화 : 식별자에 메모리를 할당하고 undefined 상태를 부여한다.
  3.  할당 : 변수 안에 직접 값을 넘겨 준다.

호이스팅을 여러 곳에서 쓰입니다.
대표적으로 function을 사용한 호이스팅이 사용되고 있습니다.
하지만 변수 호이스팅은 엄격하게 금지되고 있습니다.

일반적으로 저희는 위에서 아래로 흘러가는 로직의 흐름에 익숙해져 있습니다.
그로인해 호이스팅으로 일어나는 런타임 결과는 예측하기가 힘들어져 사용을 지양해야 합니다.

## 4.5 값의 할당

이번 목차에서 가장 주의해서 본 점은 `자바스크립트 엔진은 변수 선언과 값의 할당을 하나의 문으로 단축 표현해도 변수 선언과 값의 할당을 2개의 문으로 나누어 각각 실행한다`이였습니다.

또한 이때 주의할 점은 변수 선언과 값의 할당의 실행 시점이 다르다는 것인데,
얕게나마 알고 있던 점을 이번에 자바스크립트 엔진이 값을 할당하는지 이해했습니다.

> 변수 선언은 소스코드가 순차적으로 실행되는 시점인 런타임 이전에 먼저 실행되지만 값의 할당은 소스코드가 순차적으로 실행되는 시점인 런타임에 실행된다.

![스크린샷 2022-12-02 오전 12 33 59](https://user-images.githubusercontent.com/66871265/205093994-a9696fec-1ea7-432e-9971-80155f72e2d9.png)

이전 값인 undefined가 저장되어 있던 메모리 공간을 지우고 그 메모리 공간에 할당 값 80을 새롭게 저장하는 것이 아니라 아예 새로운 메모리 공간을 확보하고 그곳에 할당한다...!

> 이렇게 이전의 값들이 메모리 공간에 쓸데 없이 저장되어있는 것은 자바스크립트 엔진이 가비지 콜렉터로 정리한다. (언제 정리하는지는 모름)
