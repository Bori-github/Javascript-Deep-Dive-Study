## 📂 4.1 변수란 무엇인가? 왜 필요한가?

- 컴퓨터는 모든 데이터를 **2진수**로 처리한다.
  ⇒ 따라서, 메모리에 저장되는 데이터는 데이터의 종류(숫자, 텍스트, 이미지 등)와 상관없이 모두 2진수로 저장된다.
- 메모리<sup>memory</sup> : 데이터를 저장할 수 있는 메모리 셀<sup>memory cell</sup>의 집합체
  - 메모리 셀 하나의 크기 : 1 바이트(8 비트)
  - 컴퓨터는 1 바이트(메모리 셀의 크기) 단위로 데이터를 저장<sup>write</sup>하거나 읽어<sup>read</sup>들인다.
  - 각 셀은 고유의 **메모리 주소<sup>memory address</sup>** 를 갖는다.
    ⇒ 메모리 주소는 메모리 공간의 위치를 나타냄

[예제 04-01]

```javascript
10 + 20;
```

#### 자바스크립트 엔진이 위의 자바스크립트 코드를 계산(평가<sup>evaluation</sup>)하려면?

- `10`, `20`, `+` 라는 기호(리터럴<sup>literal</sup>과 연산자<sup>operator</sup>)의 의미를 알아야 한다.
- `10 + 20` 이라는 식(표현식<sup>expression</sup>)의 의미도 해석(파싱<sup>parsing</sup>)할 수 있어야 한다.
- 자바스크립트 엔진이 `10 + 20` 이라는 식의 의미를 해석하면 `+`연산을 수행하기 위해 `+`연산자의 좌변과 우변의 값, 즉 **피연산자<sup>prerand</sup>** 를 기억한다.
  - 컴퓨터는 CPU를 사용해 연산
  - 메모리를 사용해 데이터를 기억 : 피연산자(`10`, `20`)를 메모리 어딘가에 저장하고, 연산의 결과 값인 `30` 또한 메모리 어딘가에 저장된다.

#### [문제점] CPU가 연산해서 만들어낸 결과 값을 재사용할 수 없다!

- 연산 결과를 단 한 번만 사용한다면 문제가 없다.
- 만약 연산 결과 값인 `30`을 재사용하고 싶다면?
  ⇒ 메모리 주소를 통해 저장된 **메모리 공간에 직접 접근** 해야 한다.
- 메모리 주소를 통해 값에 직접 접근하는 것은 치명적 오류를 발생시킬 수 있으므로, 자바스트립트는 개발자의 직접적인 메모리 제어를 허용하지 않는다.

⇒ 프로그래밍 언어는 기억하고 싶은 값을 메모리에 저장하고, 저장된 값을 읽어 들여 재사용하기 위해 변수라는 메커니즘 제공

### 🏷 변수<sup>variable</sup>

- 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름
- 프로그래밍 언어에서 **값을 저장하고 참조하는 메커니즘**으로, 값의 위치를 가리키는 상징적인 이름
  ⇒ 변수는 컴파일러 또는 인터프리터에 의해 값이 저장된 메모리 공간의 주소로 치환되어 실행
  ⇒ 변수를 통해 안전하게 값에 접근 가능

[예제 04-03]

```javascript
// 메모리 공간에 저장된 값 30을 재사용할 수 있도록 result라는 변수 이용
var result = 10 + 20;

// 변수명: result
// 변수 값: 30
```

- 변수 이름(변수명) : 메모리 공간에 저장된 값을 식별할 수 있는 고유한 이름
- 변수 값 : 변수에 저장된 값

> 코드는 컴퓨터에게 내리는 명령이지만 개발자를 위한 문서이기도 하다. 개발자의 의도를 나타내는 명확한 네이밍은 코드를 이해하기 쉽게 만들며, 이는 협업과 품질 향상에 도움을 준다.

## 📂 4.2 식별자

- 식별자<sup>identifier</sup> : 어떤 값을 구별해서 식별할 수 있는 고유한 이름(변수 이름을 식별자 라고도 한다)
- 식별자는 메모리 공간에 저장되어 있는 어떤 값을 구별하여 식별하기 위해 **어떤 값이 저장되어 있는 메모리 주소를 기억(저장)** 한다.
  - 식별자는 값이 아니라 메모리 주소를 기억한다.
  - 식별자는 값이 저장되어 있는 **메모리 주소와 매핑 관계**를 맺으며, 매핑 정보도 메모리에 저장되어야 한다.
- `식별자`라는 용어는 변수 이름에만 국한해서 사용하지 않는다.
  - 변수, 함수, 클래스 등의 이름은 모두 식별자다.
  - **메모리 상에 존재하는 어떤 값을 식별할 수 있는 이름**은 모두 식별자라고 부른다.
- 식별자는 네이밍 규칙을 준수해야 하며, 선언<sup>declaration</sup>에 의해 자바스크립트 엔진에 식별자의 존재를 알린다.

## 📂 4.3 변수 선언

#### 변수 선언<sup>variable declaration</sup>

- 변수를 생성하는 것
  = 값을 저장하기 위한 **메모리 공간을 확보<sup>allocate</sup>** 하고, **변수 이름과 확보된 메모리 공간의 주소를 연결<sup>name binding</sup>** 해서 값을 저장할 수 있게 준비하는 것
- 변수 선언에 의해 확보된 메모리 공간은 확보가 해제<sup>release</sup>되기 전까지 해당 공간을 사용할 수 없도록 보호된다.
- 변수를 사용하려면 반드시 선언이 필요!
- 변수를 선언할 때 `var`, `let`, `const` 키워드\* 사용

##### \* 키워드 : 자바스크립트 코드를 해석하고 실행하는 자바스크립트 엔진이 수행할 동작을 규정한 일종의 명령어이다. 자바스크립트 엔진은 키워드를 만나면 자신이 수행해야 할 약속된 동작을 수행한다.

> #### `var`, `let`, `const`
>
> - `let`, `const` 키워드는 ES6에서 도입이 되었다.
> - 그 전까지 변수를 선언할 수 있는 키워드는 `var`가 유일했다.
>   - `let`, `const` 키워드는 `var` 키워드의 단점을 보완하기 위해 도입되었다.
> - ES6는 기본적으로 하위 호환성을 유지하면서 ES5의 기반 위에 새로운 기능을 추가한 것이므로, `var` 키워드의 사용을 권장하지 않을 뿐 사용할 수 있다.
>   ⇒ ES6는 ES5의 상위 집합
>
> ##### \* 자세한 내용은 15장에서 다뤄집니다.

[예제 04-04]

```javascript
// 변수 선언(변수 선언문)
var score;
```

- 변수 선언문은 **변수 이름을 등록**하고 값을 저장할 **메모리 공간을 확보**한다.
- 변수 선언 후, 아직 변수에 값을 할당하지 않았다.
- 확보된 메모리 공간에는 자바스크립트 엔진에 의해 `undefined`라는 값이 암묵적으로 할당되어 초기화된다.

##### \* `undefined` : 자바스크립트에서 제공하는 원시 타입의 값<sup>primitive value</sup>

![](https://i.imgur.com/HgPGC7m.png)

#### 자바스크립트 엔진의 변수 선언 2단계

1. 선언 단계 : 변수 이름을 등록해서 자바스크립트 엔진에 변수의 존재를 알린다.
2. 초기화 단계 : 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 `undefined`를 할당해 초기화 한다.

- 초기화<sup>initialization</sup> : 변수가 선언된 이후 **최초로 값을 할당**하는 것
- `var` 키워드를 사용한 변수 선언
  - 선언 단계와 초기화 단계가 동시에 진행된다.
  - `undefined`로 암묵적인 초기화가 자동 수행되어 어떠한 값을 할당하지 않아도 `undefined`라는 값을 가진다.
- 초기화 단계를 거치지 않는다면?
  - 확보된 메모리 공간에 이전에 다른 애플리케이션이 사용했던 값이 남아있을 수 있다. ⇒ 쓰레기 값<sup>garbage value</sup>
  - 따라서 메모리 공간을 확보한 다음, 값을 할당하지 않은 상태에서 곧바로 변수 값을 참조하면 쓰레기 값이 나올 수 있다.
    ⇒ 자바스크립트의 `var` 키워드는 암묵적으로 초기화를 수행하므로 이러한 위험으로부터 안전하다.
- 선언하지 않은 변수(식별자)에 접근하면?
  - `ReferenceError`(참조 에러) 발생
  - `ReferenceError` : 식별자를 통해 값을 참조하려고 했으나 자바스크립트 엔진이 등록된 식별자를 찾을 수 없을 때 발생

![](https://i.imgur.com/AEIKqGU.png)
