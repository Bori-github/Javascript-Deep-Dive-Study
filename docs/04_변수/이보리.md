## 📂 4.1 변수란 무엇인가? 왜 필요한가?

- 컴퓨터는 모든 데이터를 **2진수**로 처리한다.
  ⇒ 따라서, 메모리에 저장되는 데이터는 데이터의 종류(숫자, 텍스트, 이미지 등)와 상관없이 모두 2진수로 저장된다.
- 메모리<sup>memory</sup> : 데이터를 저장할 수 있는 메모리 셀<sup>memory cell</sup>의 집합체
  - 메모리 셀 하나의 크기 : 1 바이트(8 비트)
  - 컴퓨터는 1 바이트(메모리 셀의 크기) 단위로 데이터를 저장<sup>write</sup>하거나 읽어<sup>read</sup>들인다.
  - 각 셀은 고유의 **메모리 주소<sup>memory address</sup>** 를 갖는다.
    ⇒ 메모리 주소는 메모리 공간의 위치를 나타냄

[예제 04-01]

```javascript
10 + 20;
```

#### 자바스크립트 엔진이 위의 자바스크립트 코드를 계산(평가<sup>evaluation</sup>)하려면?

- `10`, `20`, `+` 라는 기호(리터럴<sup>literal</sup>과 연산자<sup>operator</sup>)의 의미를 알아야 한다.
- `10 + 20` 이라는 식(표현식<sup>expression</sup>)의 의미도 해석(파싱<sup>parsing</sup>)할 수 있어야 한다.
- 자바스크립트 엔진이 `10 + 20` 이라는 식의 의미를 해석하면 `+`연산을 수행하기 위해 `+`연산자의 좌변과 우변의 값, 즉 **피연산자<sup>prerand</sup>** 를 기억한다.
  - 컴퓨터는 CPU를 사용해 연산
  - 메모리를 사용해 데이터를 기억 : 피연산자(`10`, `20`)를 메모리 어딘가에 저장하고, 연산의 결과 값인 `30` 또한 메모리 어딘가에 저장된다.

#### [문제점] CPU가 연산해서 만들어낸 결과 값을 재사용할 수 없다!

- 연산 결과를 단 한 번만 사용한다면 문제가 없다.
- 만약 연산 결과 값인 `30`을 재사용하고 싶다면?
  ⇒ 메모리 주소를 통해 저장된 **메모리 공간에 직접 접근** 해야 한다.
- 메모리 주소를 통해 값에 직접 접근하는 것은 치명적 오류를 발생시킬 수 있으므로, 자바스트립트는 개발자의 직접적인 메모리 제어를 허용하지 않는다.

⇒ 프로그래밍 언어는 기억하고 싶은 값을 메모리에 저장하고, 저장된 값을 읽어 들여 재사용하기 위해 변수라는 메커니즘 제공

### 🏷 변수<sup>variable</sup>

- 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름
- 프로그래밍 언어에서 **값을 저장하고 참조하는 메커니즘**으로, 값의 위치를 가리키는 상징적인 이름
  ⇒ 변수는 컴파일러 또는 인터프리터에 의해 값이 저장된 메모리 공간의 주소로 치환되어 실행
  ⇒ 변수를 통해 안전하게 값에 접근 가능

[예제 04-03]

```javascript
// 메모리 공간에 저장된 값 30을 재사용할 수 있도록 result라는 변수 이용
var result = 10 + 20;

// 변수명: result
// 변수 값: 30
```

- 변수 이름(변수명) : 메모리 공간에 저장된 값을 식별할 수 있는 고유한 이름
- 변수 값 : 변수에 저장된 값

> 코드는 컴퓨터에게 내리는 명령이지만 개발자를 위한 문서이기도 하다. 개발자의 의도를 나타내는 명확한 네이밍은 코드를 이해하기 쉽게 만들며, 이는 협업과 품질 향상에 도움을 준다.

## 📂 4.2 식별자

- 식별자<sup>identifier</sup> : 어떤 값을 구별해서 식별할 수 있는 고유한 이름(변수 이름을 식별자 라고도 한다)
- 식별자는 메모리 공간에 저장되어 있는 어떤 값을 구별하여 식별하기 위해 **어떤 값이 저장되어 있는 메모리 주소를 기억(저장)** 한다.
  - 식별자는 값이 아니라 메모리 주소를 기억한다.
  - 식별자는 값이 저장되어 있는 **메모리 주소와 매핑 관계**를 맺으며, 매핑 정보도 메모리에 저장되어야 한다.
- `식별자`라는 용어는 변수 이름에만 국한해서 사용하지 않는다.
  - 변수, 함수, 클래스 등의 이름은 모두 식별자다.
  - **메모리 상에 존재하는 어떤 값을 식별할 수 있는 이름**은 모두 식별자라고 부른다.
- 식별자는 네이밍 규칙을 준수해야 하며, 선언<sup>declaration</sup>에 의해 자바스크립트 엔진에 식별자의 존재를 알린다.

## 📂 4.3 변수 선언

#### 변수 선언<sup>variable declaration</sup>

- 변수를 생성하는 것
  = 값을 저장하기 위한 **메모리 공간을 확보<sup>allocate</sup>** 하고, **변수 이름과 확보된 메모리 공간의 주소를 연결<sup>name binding</sup>** 해서 값을 저장할 수 있게 준비하는 것
- 변수 선언에 의해 확보된 메모리 공간은 확보가 해제<sup>release</sup>되기 전까지 해당 공간을 사용할 수 없도록 보호된다.
- 변수를 사용하려면 반드시 선언이 필요!
- 변수를 선언할 때 `var`, `let`, `const` 키워드\* 사용

##### \* 키워드 : 자바스크립트 코드를 해석하고 실행하는 자바스크립트 엔진이 수행할 동작을 규정한 일종의 명령어이다. 자바스크립트 엔진은 키워드를 만나면 자신이 수행해야 할 약속된 동작을 수행한다.

> #### `var`, `let`, `const`
>
> - `let`, `const` 키워드는 ES6에서 도입이 되었다.
> - 그 전까지 변수를 선언할 수 있는 키워드는 `var`가 유일했다.
>   - `let`, `const` 키워드는 `var` 키워드의 단점을 보완하기 위해 도입되었다.
> - ES6는 기본적으로 하위 호환성을 유지하면서 ES5의 기반 위에 새로운 기능을 추가한 것이므로, `var` 키워드의 사용을 권장하지 않을 뿐 사용할 수 있다.
>   ⇒ ES6는 ES5의 상위 집합
>
> ##### \* 자세한 내용은 15장에서 다뤄집니다.

[예제 04-04]

```javascript
// 변수 선언(변수 선언문)
var score;
```

- 변수 선언문은 **변수 이름을 등록**하고 값을 저장할 **메모리 공간을 확보**한다.
- 변수 선언 후, 아직 변수에 값을 할당하지 않았다.
- 확보된 메모리 공간에는 자바스크립트 엔진에 의해 `undefined`라는 값이 암묵적으로 할당되어 초기화된다.

##### \* `undefined` : 자바스크립트에서 제공하는 원시 타입의 값<sup>primitive value</sup>

![](https://i.imgur.com/HgPGC7m.png)

#### 자바스크립트 엔진의 변수 선언 2단계

1. 선언 단계 : 변수 이름을 등록해서 자바스크립트 엔진에 변수의 존재를 알린다.
2. 초기화 단계 : 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 `undefined`를 할당해 초기화 한다.

- 초기화<sup>initialization</sup> : 변수가 선언된 이후 **최초로 값을 할당**하는 것
- `var` 키워드를 사용한 변수 선언
  - 선언 단계와 초기화 단계가 동시에 진행된다.
  - `undefined`로 암묵적인 초기화가 자동 수행되어 어떠한 값을 할당하지 않아도 `undefined`라는 값을 가진다.
- 초기화 단계를 거치지 않는다면?
  - 확보된 메모리 공간에 이전에 다른 애플리케이션이 사용했던 값이 남아있을 수 있다. ⇒ 쓰레기 값<sup>garbage value</sup>
  - 따라서 메모리 공간을 확보한 다음, 값을 할당하지 않은 상태에서 곧바로 변수 값을 참조하면 쓰레기 값이 나올 수 있다.
    ⇒ 자바스크립트의 `var` 키워드는 암묵적으로 초기화를 수행하므로 이러한 위험으로부터 안전하다.
- 선언하지 않은 변수(식별자)에 접근하면?
  - `ReferenceError`(참조 에러) 발생
  - `ReferenceError` : 식별자를 통해 값을 참조하려고 했으나 자바스크립트 엔진이 등록된 식별자를 찾을 수 없을 때 발생

![](https://i.imgur.com/AEIKqGU.png)

## 📂 4.4 변수 선언의 실행 시점과 변수 호이스팅

[예제 04-05]

```javascript
// 1. 변수 score를 참조하는 코드
console.log(score); // undefined

// 2. 이 후 변수 score를 선언
var score;
```

#### 변수 선언문보다 변수를 참조하는 코드가 앞에 있는데 왜 참조 에러<sup>ReferenceError</sup>가 발생하지 않을까?

- 자바스크립트 코드는 인터프리터에 의해 한 줄씩 순자적으로 실행
  - 변수 선언문 전 변수 참조를 먼저하게 될 경우, 선언되지 않은 변수를 참조하려고 시도한 것이므로 참조 에러가 발생해야하지 않을까?
  - 참조 에러가 발생하지 않고 `undefined`를 정상적(?)으로 출력하는 이유는 무엇일까?
- **변수 선언은 런타임<sup>runtime</sup>**(소스코드가 한 줄씩 순차적으로 실행되는 시점) **이 전 단계에서 먼저 실행**된다.
- 자바스크립트 엔진의 소스코드 실행 단계
  - 소스코드 실행 전, **소스코드의 평가 과정**(준비 단계)을 거친다.
    ⇒ 이 단계에서 **모든 선언문(변수 선언문, 함수 선언문 등)을 소스코드에서 찾아내 먼저 실행**
  - 소스코드 평가 과정이 끝난 후, 소스코드를 한 줄씩 순차적으로 실행

⇒ 자바스크립트 엔진은 변수 선언이 소스코드의 어디에 있든 상관없이 다른 코드보다 먼저 실행
⇒ 따라서, **변수 선언의 위치에 상관없이 어디서든지 변수를 참조할 수 있다.**

### 🏷 변수 호이스팅<sup>variable hoisting</sup>

- **변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작**하는 자바스크립트 고유의 특징
- `var`, `let`, `const`, `function`, `function*`, `class` 키워드를 사용해서 선언하는 모든 식별자(변수, 함수, 클래스 등)는 호이스팅된다.
  ⇒ 모든 선언문은 런터임 이전 단계에서 먼저 실행되기 때문!

## 📂 4.5 값의 할당

변수에 값을 할당<sup>assignment</sup>(대입, 저장)할 때, **할당 연산자** 사용

- 기호 : `=`
- 우변의 값을 좌변의 변수에 할당

[예제 04-06]

```javascript
var score; // 변수 선언
score = 80; // 변수에 값을 할당

// 단축 표현
var score = 80; // 변수 선언과 값의 할당
```

- 변수 선언과 값의 할등을 2개의 문<sup>statement</sup>으로 나누어 표현한 코드 **vs** 변수 선언과 값의 할당을 하나의 문으로 단축 표현한 코드
  ⇒ 정확히 동일하게 동작
  ⇒ 자바스크립트 엔진은 단축 표현한 코드여도 변수 선언과 값의 할당을 **2개의 문으로 나누어 각각 싱행**
- <span style="color: red">주의사항</span> : 변수 선언과 값의 할당은 실행 시점이 다르다!
  - 변수 선언은 런타임 이전에 먼저 실행
  - 값의 할당은 런타임에 실행

[예제 04-08]

```javascript
console.log(score);

var score; // 변수 선언
score = 80; // 값의 할당

console.log(score);
```

![](https://i.imgur.com/WSvsF6I.png)

[예제 04-09]

```javascript
console.log(score);

var score = 80; // 변수 선언과 값의 할당

console.log(score);
```

![](https://i.imgur.com/JMvBZSm.png)

[예제 04-10]

```javascript
console.log(score);

score = 80; // 값의 할당
var score; // 변수 선언

console.log(score);
```

![](https://i.imgur.com/q4a4zC4.png)

## 📂 4.6 값의 재할당

#### 재할당

- 이미 값이 할당되어 있는 변수에 새로운 값을 또다시 할당하는 것
- 현재 변수에 저장된 값을 버리고 새로운 값을 저장하는 것
- `var` 키워드로 선언한 변수는 선언과 동시에 `undefined` 로 초기화되므로, 엄밀히 말하자면 변수에 처음 값을 할당하는 것도 재할당이다.

##### \* `var` 키워드로 선언한 변수는 값을 재할당할 수 있다.

[예제 04-11]

```javascript
var score = 80; // 변수 선언과 값의 할당
score = 90; // 값의 재할당
```

> 재할당은 변수에 저장된 값을 다른 값으로 변경 ⇒ **변수**라고 하는 이유
>
> 값을 재할당할 수 없어서 변수에 저장된 값을 변경할 수 없다면?
> **상수<sup>constant</sup>**
>
> - 한번 정해지면 변하지 않는 값
> - 단 한 번만 할당할 수 있는 변수

- 변수에 값을 할당할 때 이전 값 `undefined`가 저장되어 있던 메모리 공간을 지우고 그 메로리에 할당 값 `80`을 새롭게 저장하는 것이 아니라 새로운 메모리 공간을 확보하고 그곳에 할당 값 `80`을 저장한다.
- 재할당도 마찬가지로 새로운 메모리 공간을 확보하고 그 메모리 공간에 숫자 값 `90`을 저장한다.

[그림 4-10 값의 재할당]
![](https://velog.velcdn.com/images%2Fmr_chu%2Fpost%2F6eec5b62-8105-483e-bfff-088b9318c8dd%2F%EB%B3%80%EC%88%98%20%EC%9E%AC%ED%95%A0%EB%8B%B9.jpeg)

- 현재 score 변수의 값은 `90`
- 이전 값인 `undefined`와 `80`은 어떤 변수도 값으로 가지고 있지 않은 상태
  ⇒ 어떤 식별자와도 연결되어 있지 않은 상태
- 아무도 사용하고 있지 않는 불필요한 값들은 가비지 콜렉터에 의해 메모리에서 자동으로 해제된다.
  - 단, 메모리에서 언제 해제될지는 예측 불가

> #### 가비지 콜렉터<sup>garbage collector</sup>
>
> - 애플리케이션이 할당한 메모리 동간을 주기적으로 검사하여 더 이상 사용되지 않는 메모리를 해제하는 기능
> - 더 이상사용되지 않는 메모리란 어떤 식별자도 참조하지 않는 메모리 공간을 의미
> - 가비지 콜렉터를 통해 메모리 누수<sup>memory leak</sup>를 방지
