## 4.1 - 변수란?

변수는 **하나의 값**을 **저장**하기 위해 확보한 메모리 공간 자체, 혹은 메모리 공간을 식별하기 위해 붙인 이름이다.

- 값(데이터)의 위치를 가르키는 **상징적인** 이름이다.
- C, C++등의 언어에선 같이 포인터를 이용해 메모리에 접근할 수 있지만, JS에서는 직접 접근할 수 없다.

> 할당: 변수에 값을 저장하는 것 (대입)  
> 참조: 변수의 값을 읽는 것  
> 식별자: 메모리에 저장된 값을 식별할 수 있는 이름

<br />

## 4.2 - 식별자

식별자는 어떤 값을 **구별**해서 식별할 수 있는 **고유한** 이름이다.

- 값이 아니라 **메모리 주소**, 매핑 관계, 매핑 정보 등을 저장하고 있다.
- 변수명, 함수명, 클래스명 등의 이름도 모두 식별자이다.
- 메모리에 존재하는 값을 식별할 수 있는 이름은 전부 식별자라고 부른다.

<br />

## 4.3 - 변수 선언

변수 선언은 변수를 생성한다는 뜻이다.

- 값을 저장하기 위한 **공간을 확보**하고, 이름과 **메모리 공간을 연결**한다. (준비)
- `var` / `let` / `const` 등의 키워드를 사용한다. `var` 은 부작용이 생길 수 있기 때문에, 사용을 지양해야한다.

```javascript
var score; // 선언은 되었지만, 값을 할당하지 않음 (초기화 X)
```

- 선언을 하고 초기화하지 않으면, JS 자체의 특성으로 `undefined` 값이 암묵적으로 할당되어 **초기화**된다.
- **쓰레기 값** 참조를 방지하기 위해서이다.

<br />

## 4.4 - 변수 선언의 실행 시점과 변수 호이스팅

- 변수 선언이 순차적으로 실행되는 **런타임** 이전에 먼저 실행된다.
  - JS 엔진의 **평가**: 모든 선언문을 찾아서 먼저 실행한다.
    (선언과 암묵적 초기화)
  - JS 엔진의 **런타임**: 선언문을 제외한 소스코드를 한 줄씩 순차적으로 실행한다.
- JS 엔진은 변수 선언이 소스코드 어디에 있던 먼저 실행(평가단계)한다. 이런 특징을 **변수 호이스팅**이라고 한다.

**호이스팅**

```javascript
console.log(foo); // undefined
var foo;

console.log(bar); // Error: Uncaught ReferenceError: bar is not defined
let bar;
```

- 호이스팅이란, `var` 선언문이나, `function` 선언문 등을 해당 스코프의 **선두로 옮긴 것**처럼 동작하는 특성이다.
- `var`은 선언과 동시에 초기화가 되어 오류가 발생하지 않지만, `let` 으로 선언된 변수는 선언 단계와 초기화 단계가 분리되어 진행된다.
- `let` 으로 선언된 변수는 스코프의 시작에서 변수의 선언까지
  **일시적 사각지대(Temporal Dead Zone; TDZ)** 에 빠지기 때문이다.

<br />

## 4.5, 4.6 - 값의 할당과 재할당

```javascript
var num; // 변수 선언
num = 80; // 값의 할당
var num = 80; // 변수 초기화

num = 100; // 재할당
```

- 변수 선언은 런타임 단계 이전에 실행되지만, 값의 할당은 소스코드가 순차적으로 실행되는 런타임 단계에서 실행된다.
- 재할당은 이미 값이 할당되어 있는 변수에 새로운 값을 다시 할당하는 것이다.
- 변수와 다르게 상수는 값을 재할당 할 수 없다. (선언 시 무조건 변수를 초기화 해야한다.)

**재할당과 가비지 콜렉터(Garbage Collector)**
- 기존 값 80을 지우고 그 메모리에 100을 재할당 하는 것이 아닌,
 새로운 메모리 공간을 확보하고 그 공간에 100의 값을 저장한다.
- 기존 값은 가바지 콜렉터에 의해서 자동 해제된다.
- JS는 가바지 콜렉터를 내장하고 있으며, 이를 통해 메모리 누수를 방지한다.



<br />
