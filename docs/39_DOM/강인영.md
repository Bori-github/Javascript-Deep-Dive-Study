# 39. DOM

## 39.1 노드

### 39.1.1 HTML 요소와 노드 객체

> <div class=”gretting”>Hello</div>
> 
- <div> - 시작태그
- class - 속성 이름
- “greeting” - 속성 값
- Hello - 내용
- </div> - 종료태그
- **HTML Element → Parsing & Rendering → DOM을 구성하는 element node 객체로 변환**
    - element → element node
    - attribute → attribute node
    - text content → text node
- **`DOM(Document Object Model)`: 노드 객체로 구성된 트리 자료구조**

### 39.1.2 노드 객체의 타입

- **document node**
    - **전역 객체 window**의 document 프로퍼티에 바인딩되어 있음
    - window.document / document 로 참조 가능
    - **HTML 문서 당 document 객체는 유일(root node)**
- **element node**
- **attribute node**
- **text node**
    - leaf node(Dom Tree의 최종단)
- 나머지 노드를 포함, 총 12개의 노드 타입이 존재함
    - Comment, DocumentType, DocumentFragment 등

### 39.1.1 노드 객체의 상속 구조

- **DOM을 구성하는 노드 객체** ⇒ ECMAScript에 정의된 표준 빌트인 객체가 아닌, 브라우저 환경에서 추가적으로 제공하는 호스트 객체이다. 하지만 노드 객체는 JS 객체이므로 프로토타입에 의한 상속 구조를 가진다.
- **Object, EventTarget, Node Interface**를 상속받음
    - **document node** → Document, HTMLDocument,
    - **attribute node** → Attr
    - **text node** → CharacterData
    - **element node** → Element Interface를 상속받음(+ HTMLHtmlElement, HTMLHeadElement, HTMLBodyElement, HTMLUListElement...)
- 노드 객체의 상속 구조는 **개발자 도구 Properties** 패널에서 확인 가능
- 노드 관련 기능
    - **EventTarget Interface**: EventTarget.addEventListener,
    - **Node Interface**: Node.parentNode, Node.childNodes, Node.previousSibling, Node.nextSibling, Node.nodeType, Node.nodeName, …

## 39.2 element node 취득

### 39.2.1 id

- `document.getElementById`
    - id 값을 갖는 첫 번째 element node만 반환하며, 없다면 null을 반환함
    - 부수 효과: id를 부여하면 그 값과 동일한 전역 변수가 암묵적으로 선언됨. 하지만 해당 이름의 전역 변수가 이미 선언된 경우, 이 전역 변수에 **노드 객체는 재할당되지 않음**.

### 39.2.2 tag name

- `document.getElementsByTagName`
    - 여러 개의 element node를 갖는 HTMLCollection 객체를 반환(유사 배열 객체, iterable)
    - 값이 없다면 빈 HTMLCollection 객체를 반환함
    - HTML 문서의 모든 element node를 취득하려면 document.getElementsByTagName(’*’);
    - $fruits.getElementsByTagName 도 가능!
        - Document.Prototype, **Element.Prototype**에 둘 다 정의되어 있기 때문

### 39.2.3 class

- `Document.prototype/Element.prototype.getElementsByClassName`
    - HTMLCollection 객체를 반환함
    - class는 공백으로 구분하여 여러 개 전달 가능함.

### 39.2.4 CSS 선택자

- `Document.prototype/Element.prototype.querySelector`
    - 인수로 전달한 CSS 선택자를 만족시키는 요소 노드가 여러 개인 경우 **첫 번째 요소 노드만** 반환한다.
    - 없는 경우 `null`을 반환한다.
    - 선택자가 문법에 맞지 않는 경우 **DOMException 에러**가 발생한다.
- `Document.prototype/Element.prototype.querySelectorAll()`
    - **NodeList 객체**를 반환(유사 배열 객체, 이터러블)
    - 해당 요소가 존재하지 않는 경우 **빈 NodeList 객체**를 반환함
    - 선택자가 문법에 맞지 않는 경우 **DOMException 에러**가 발생한다.
    - document.querySelector(’*’); 가능*
- `querySelector`*,* `querySelectorAll`*은* `getElementById`*,* `getElementsBy**` 메서드보다 다소 느리지만, 구체적인 조건으로 요소 노드 취득할 수 있으며 일관된 방식으로 노드 취득이 가능하다.
    - id가 있을 때는 **getElementById**를, 그 밖에는 **querySelector** 메서드 이용이 권장됨.

### 39.2.5 특정 요소 노드를 취득할 수 있는지 확인

- `Element.prototype.matches`: 인수로 전달한 CSS 선택자를 통해 특정 element node를 취득할 수 있는지 확인함.
- $apple.matches(’#fruits > li.apple’);

### 39.2.6 HTMLCollection과 NodeList

- 모두 유사 배열 객체이며 iterable.
    - for…of, 스프레드 문법 사용 가능함
- 노드 객체의 상태 변화를 실시간으로 반영(live)
    - **HTMLCollection은 항상 live**
        - 실시간으로 요소 변경이 이루어지면 해당 요소가 제거될 위험이 있으므로 for문을 거꾸로 순회하는 방식으로 우회할 수 있음
        - 유사 배열 객체이자 이터러블 → 배열로 변환하면 forEach, map, filter, reduce 등을 사용할 수 있음
            - [...$elems].forEach( e ⇒ e.className = ‘blue’);
    - NodeList는 과거의 정적 상태를 유지하는 non-live로 동작하지만, live일 때도 있음
        - NodeList는 forEach, item, entries, keys, values 메서드 사용 가능
        - ⚠childNodes 프로퍼티가 반환하는 NodeList 객체는 live 객체
    
    ⇒ HTMLCollection, NodeList 모두 [...000] **스프레드 문법 혹은 Array.from 메서드를 사용하여 배열로 변환**하여 사용하는 편이 부수효과를 방지하고, 예상하지 못한 문제를 방지하며 안전하게 사용할 수 있다.
    

## 39.3 노드 탐색

- **모두 읽기 전용 접근자 프로퍼티**
- `Node.prototype`
    - **parentNode**
    - **previousSibling**
    - **firstChild**
    - **childNodes**
- `Element.prototype`
    - **previousElementSibling**
    - **nextElementSibling**
    - **children**

### 39.3.1 공백 text node

- space, tab, 줄바꿈 → text node 생성

### 39.3.2 child node 탐색

- `Node.prototype.childNodes` → NodeList 반환 (element+text node)
- `Element.prototype.children` → HTMLCollection 반환(element node만)
- `Node.prototype.firstChild` → NodeList 반환(element+text node)
- `Element.prototype.firstElementChild` → HTMLCollection 반환(element node만)
- `Node.prototype.lastChild` → NodeList 반환(element+text node)
- `Element.prototype.lastElementChild` → HTMLCollection 반환(element node만)

### ****39.3.3. child node 존재 확인****

- `Node.prototype.hasChildNodes` → true, false (요소, 텍스트 노드 모두 확인)
- `Node.prototype.children.length` → true, false (요소 노드만 체크)
- `Element.prototype.childElementCount` → true, false (요소 노드만 체크)

### ****39.3.4. element node의 text node 탐색****

- text node of element node ⇒ child node of element node / `Node.prototype.firstChild`

### ****39.3.5. 부모 노드 탐색****

- `Node.prototype.parentNode` → text node는 parent node일 수 없음

### ****39.3.6. 형제 노드 탐색****

- `Node.prototype.previousSibling` → element+text
- `Node.prototype.nextSibling` → element+text
- `Element.prototype.previousElementSibling` → element
- `Element.prototype.nextElementSibling` → element

## ****39.4. 노드 정보 취득****

- `Node.prototype.nodeType`
    - element node, Node.ELEMENT_NODE
    - text node, Node.TEXT_NODE
    - documet node, Node.DOCUMENT_NODE
- `Node.prototype.nodeName`
    - element node: 대문자로 태그 이름 반환
    - text node: #text
    - document node: #document

---

### 느낀 점

- 어떤 자료(강의 또는 교재)로 JS를 배우든, HTML를 깊게 다루지 않을 수가 없구나..
- 동시에 JS 문법을 잘 안다고 해서 HTML를 잘 아는 것이 아님을 요새 크게 체감하고 있다.
    - HTML 태그 중 **시맨틱 태그**에 대해서 제대로 이해하지 않고 div나 p 태그를 남발하는 실수를 저지르지 말자…
    - 생각보다 우리는 주어진 자원을 충분히 활용하지 못할 때가 많다고 생각한다.
- 우테코 로또 미션을 수행할 때 element node를 가져오기 위해 getElementByID를 남발한 과오가 떠오른다.. 다른 방식과의 차이를 알지 못한 채, 단지 탐색이 빠르다는 이유만으로 저 방식을 고집했다. 리팩터링할 때는 utils 폴더에 querySelector로 element node를 가져오도록 바꾸어서, 가독성도 높이고 코드에 통일감을 주었다.
- 때로는 교과서로 개념을 한번이라도 훑어보는 것이 성급한 개발보다는 낫다.