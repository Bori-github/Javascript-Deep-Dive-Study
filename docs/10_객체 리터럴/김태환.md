# 10장 객체 리터럴

## 10.1 객체란?

Javascript는 <b>객체<sup>object</sup></b> 기반의 프로그래밍 언어이다.

원시 값을 제외한 모든 값(함수, 배열, 정규 표현식 등)은 모두 객체이다.

즉, 하나의 값만 나타내는 원시 타입과는 달리 객체 타입<sup>object/reference type</sup>은 다양한 타입의 값을 하나의 단위로 구성한 복합적인 자료구조<sup>data structure</sup>다.

또, 원시 값은 변경 불가능하나 객체는 변경 가능한 값이다.

객체는 0개 이상의 프로퍼티로 구성된 집합이며, 이 프로퍼티는 키<sup>key</sup>와 값<sup>value</sup>로 구성된다.

> <i>메서드<sup>method</sup>? 프로퍼티 값이 함수인 경우, 일반 함수와 구분하기 위해 일컫는 말.</i>

객체는 프로퍼티와 메서드로 구성된 집합체다.

- 프로퍼티: 객체의 상태를 나타내는 값(data)
- 메서드: 프로퍼티(상태 데이터)를 참조하고 조작할 수 있는 동작(behavior)

## 10.2 객체 리터럴에 의한 객체 생성

C++, Java 같은 클래스 기반 객체지향 언어는 클래스를 사전에 정의하고 필요한 시점에 new 연산자와 함계 생성자<sup>constructor</sup>를 호출하여 인스턴스를 생성하는 방식으로 객체를 생성한다.

> <i>인스턴스<sup>instance</sup>? 클래스에 의해 생성되어 메모리에 저장된 실체이다.
>
> > 객체 > 클래스 + 인스턴스. 클래스는 인스턴스를 생성하는 템플릿(틀) 역할. 인스턴스는 찍혀낸, 생성된 실체.</i>

Javascript에서는

- 객체 리터럴
- Object 생성자 함수
- 생성자 함수
- Object.create 메서드
- 클래스(ES6)

와 같은 객체 생성 방법을 지원한다.

이 중, 일반적으로 객체 리터럴을 사용하는 방법으로 아래 코드 예시와 같이 {} 내에 프로퍼티를 정의하고 객체를 생성한다.

```
const person = {
  name: 'taehwan',
  sayHello: () => {
    console.log(`Hello! This is ${this.name}.`);
  }
};
```

이 때, 객체 리터럴의 {}는 코드 블록을 의미하지 않는다. (따라서, 중괄호 끝에 세미 콜론 ;이 붙는다)

## 10.3 프로퍼티

프로퍼티는 객체를 구성하는 요소이며,

- 프로퍼티 키: 빈 문자열을 포함하는 모든 문자열 또는 심벌 값
- 프로퍼티 값: Javascript에서 사용할 수 있는 모든 값

으로 구성된다.

프로퍼티 키는 프로퍼티 값에 접근할 수 있는 이름으로서 식별자 역할을 한다.

위 코드 예시에서 객체 person의 프로퍼티 키는 name이며, 프로퍼티 값은 'taehwan'이 된다.

프로퍼티 키는 식별자로서 반드시 식별자 네이밍 규칙을 따를 필요는 없으나, 이 때에는 '...'로 묶어야 한다.

그렇지 않은 경우 연산자가 있는 표현식으로 해석하고 SyntaxError 에러를 발생 시킬 수 있다.

```
const obj = {}
const key = 'hello';
obj[key] = 'world';
// obj = {hello: 'world'}
```

위 코드 예시에서 처럼 문자열로 평가할 수 있는 표현식을 통해 프로퍼티 키를 동적으로 생성할 수도 있다.

프로퍼티 키는 문자열 또는 심벌 값만 올 수 있기 때문에, 이 외의 값(숫자 리터럴 등)을 사용하는 경우 암묵적 타입 변환을 통해 문자열이 된다.

이 외로도 Javascript 키워드(var, function 등)를 사용할 수도 있으나, 예상치 못한 에러를 방지하기 위해 사용하지 않는다.

## 10.4 메서드

Javascript의 함수는 객체(일급 객체)이다. (18장에서 더 자세히 다룸)

따라서, 함수도 값으로 취급할 수 있기 때문에 프로퍼티 값으로 사용할 수 있다.

이처럼 객체에 묶여 있는 함수를 <b>메서드<sup>method</sup></b>라 부른다.

## 10.5 프로퍼티 접근

프로퍼티에 접근하는 방법은

- 마침표 표기법<sup>dot notaion</sup>: 마침표 프로퍼티 접근 연산자(.)를 사용
- 대괄호 표기법<sup>bracket notation</sup>: 대괄호 프로퍼티 접근 연산자([...])를 사용

, 2가지이다.

프로퍼티 키가 식별자 네이밍 규칙을 준수하는 경우 두 표기법 모두 사용할 수 있지만, 준수하지 않은 경우 또는 숫자인 경우에는 아래 코드 예시처럼 대괄호 표기법만 가능하다.

```
const num = {
  1: 10,
};
console.log(num.1);     // SyntaxError: Unexpected number
console.log(num[1]);    // 10
console.log(num['1']);  // 10
```

```
const me = {
  name: 'taehwan',
};
console.log(me.name);     // taehwan
console.log(me['name']);  // taehwan
console.log(me[name]);    // ReferenceError: name is not defined
console.log(me.age);      // undefined
```

위 코드 예시처럼 프로퍼티에 접근할 수 있으나, 대괄호 표기법 사용 시에는 따옴표로 감싸야 한다.

그렇지 않은 경우 식별자로 해석하여 객체 내의 프로퍼티가 아닌 name이 선언된 곳을 찾기 때문에 에러가 발생할 수 있다.

`me.age`와 같이 객체에 존재하지 않는 프로퍼티에 접근하면 undefined를 반환한다.

## 10.6 프로퍼티 값 갱신

이미 존재하는 프로퍼티에 값을 할당하면 프로퍼티 값이 갱신된다.

## 10.7 프로퍼티 동적 생성

존재하지 않는 프로퍼티에 값을 할당하면 프로퍼티가 동적으로 생성되어 추가되고 프로퍼티 값이 할당된다.

## 10.8 프로퍼티 삭제

delete 연산자는 객채의 프로퍼티를 삭제한다.

```
const person = {
  name: 'taehwan',
};
person.age = 25;
delete person.age;
```

위 코드 예시처럼 동적 생성된 프로퍼티 age를 delete 연산자로 삭제할 수 있으며, 이 때, 프로퍼티 값에 접근할 수 있는 표현식이 피연산자로 와야한다.

존재하지 않는 프로퍼티를 삭제하고자 할 때에는 아무런 에러가 발생하지 않고 무시된다.

## 10.9 ES6에서 추가된 객체 리터럴의 확장 기능

<i>ES6에서 제공하는 더욱 간편하고 표현력 있는 객체 리터럴의 확장 기능 알아보기</i>

#### 10.9.1 프로퍼티 축약 표현

객체 리터럴의 프로퍼티에서 프로퍼티 값은 변수에 할당된 값, 즉 식별자 표현식일 수도 있다.

이 때, 아래 코드 예시처럼 프로퍼티 값으로 사용된 변수 이름과 프로퍼티 키가 동일한 이름일 때 프로퍼티 키를 생략<sup>property shorthand</sup>할 수 있다.

```
let x = 1, y = 2;
const obj = {x, y};
console.log(obj);   // {x: 1, y: 2}
```

#### 10.9.2 계산된 프로퍼티 이름

문자열 또는 문자열로 타입 변환할 수 있는 값으로 평가되는 표현식을 사용해 프로퍼티 키를 동적으로 생성할 수 있다.

이 때, 프로퍼티 키로 사용할 표현식을 대괄호[]로 묶어야 한다. 이를 계산된 프로퍼티 이름<sup>computed property name</sup>이라 한다.

하지만, ES6에서는 아래 코드 예시처럼 객체 리터럴 내부에서도 계산된 프로퍼티 이름으로 프로퍼티 키를 동적 생성할 수 있다.

```
const prefix = 'prop';
let i = 0;
const obj = {
  [`${prefix} - ${++i}`]: i,
  [`${prefix} - ${++i}`]: i,
  [`${prefix} - ${++i}`]: i,
};
console.log(obj);   // {prop-1: 1, prop-2: 2, prop-3: 3}
```

#### 10.9.3 메서드 축약 표현

ES5에서는 객체 리터럴 내에서 메서드를 정의하려면 프로퍼티 값으로 function 키워드를 사용한 익명함수를 할당한다.

ES6에서는 메서드를 정의할 때, 아래 코드 예시처럼 function 키워드를 생략한 축약 표현을 사용할 수 있다.

```
const obj = {
  name: 'taehwan',
  sayHello(){
    console.log(`Hello, this is ${this.name}!`);
  }
};
obj.sayHello();   // Hello, this is taehwan!
```

<i>단, 메서드 축약 표현으로 정의한 메서드는 프로퍼티에 할당한 함수와 다르게 동작한다.(26장에서 자세히 다룸)</i>

<br>
<hr>
<br>

## 👀 되돌아보기

- <b>객체</b>
  <br>프로퍼티와 메서드로 구성된 집합체로, 다양한 타입의 값을 하나의 단위로 구성한 복합 자료구조
- <b>클래스와 인스턴스</b>
  <br>클래스는 붕어빵 틀과 같은 것(템플릿)이고, 인스턴스는 그 빵틀로 찍어낸 먹는 붕어빵 같은 것(객체의 '메모리에 존재하는' 실체)
- <b>프로퍼티</b>
  <br>프로퍼티는 객체를 구성하는 요소로, 키(식별자 역할)과 값(데이터)로 구성된다.
- <b>메서드</b>
  <br>프로퍼티는 객체를 구성하는 요소로, 키(식별자 역할)과 값(데이터)로 구성된다.
- <b>프로퍼티 접근법</b>
  - 마침표 표기법<sup>dot notaion</sup>: 마침표 프로퍼티 접근 연산자(.)를 사용
  - 대괄호 표기법<sup>bracket notation</sup>: 대괄호 프로퍼티 접근 연산자([...])를 사용
- <b>객체 리터럴 확장 기능(ES6)</b>
  - 프로퍼티 축약 표현: 프로퍼티 값에 사용된 변수명과 프로퍼티 키가 동일한 경우 프로퍼티 키 생략 가능
  - 계산된 프로퍼티 이름: 객체 리터럴 내에서도 계산된 프로퍼티 이름으로 프로퍼티 키를 동적으로 생성 가능
  - 메서드 축약 표현: 객체 리터럴 내에서 메서드 정의 시에 function 키워드 생략 가능
