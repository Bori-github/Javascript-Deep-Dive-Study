# 45장 프로미스

## 📂 45.1 비동기 처리를 위한 콜백 패턴의 단점
### 콜백 헬
#### 비동기 함수
- 함수 내부에 비동기로 동작하는 코드를 포함한 함수
- 비동기 함수를 호출하면 함수 내부의 비동기로 동작하는 코드가 완료되지 않았다 해도 기다리지 않고 즉시 종료
⇒ 비동기 함수 내부의 비동기로 동작하는 코드는 비동기 함수가 종료된 이후에 완료됨
- 따라서 비동기 함수 내부의 비동기로 동작하는 코드에서 처리 결과를 외부로 반환하거나 상위 스코프의 변수에 할당할 수 없다.

#### 비동기 함수 내부의 처리 결과를 상위 스코프의 변수에 할당할 수 없는 이유

```javascript
// 서버의 응답을 상위 스코프의 변수로 할당
let todos;

// GET 요청을 위한 비동기 함수
const get = (url) => {
  const xhr = new XMLHttpRequest();
  xhr.open("GET", url);
  xhr.send();

  xhr.onload = () => {
    if (xhr.status === 200) {
      // ① 서버의 응답을 상위 스코프 변수에 할당
      todos = JSON.parse(xhr.response);
    } else {
      console.error(`${xhr.status} ${xhr.statusText}`);
    }
  };
};

// idrk 1인 post 취득
get("https://jsonplaceholder.typicode.com/posts/1");
console.log(todos); // ② undefined
```

- 비동기 함수 `get` 호출
  - `get` 함수의 실행 컨텍스트가 생성
  - 실행 컨텍스트 스택에 푸시
  - 이후 함수 코드 실행 과정에서 `xhr.onload` 이벤트 핸들러 프로퍼티에 이벤트 핸들러가 바인딩된다.
  - `get` 함수가 종료하면 `get` 함수의 실행 컨텍스트가 콜 스택에서 팝
- 곧바로 ②의 `console.log` 호출
  - `console.log`의 실행 컨텍스트 생성
  - 실행 컨텍스트 스택에 푸시
  - `console.log`가 호출되기 직전에 load 이벤트가 발생했더라도 `xhr.onload` 이벤트 핸들러 프로퍼티에 바인딩한 이벤트 핸들러는 `console.log`보다 먼저 실행되지 않는다.
- 서버로부터 응답이 도착하면 `xhr` 객체에서 load 이벤트 발생
  - 이때 `xhr.onload` 핸들러 프로퍼티에 바인딩한 이벤트 핸들러가 즉시 실행되지 않는다.
  - `xhr.onload` 이벤트 핸들러는 load 이벤트가 발생하면 일단 태스크 큐에 저장되어 대기하다가, 콜 스택이 비면 이벤트 루프에 의해 콜 스택으로 푸시되어 실행
  - 이벤트 핸들러도 함수이므로 `이벤트 핸들러의 평가 → 이벤트 핸들러의 실행 컨텍스트 생성 → 콜 스택에 푸시 → 이벤트 핸들러 실행` 과정을 거친다.
- `xhr.onload` 이벤트 핸들러가 실행되는 시점에 콜 스택이 빈 상태여야 하므로 ②의 `console.log`는 이미 종료된 이후다.
⇒ `xhr.onload` 이벤트 핸들러에서 상위 스코프의 변수에 서버의 응답 결과를 할당하기 전에 `console.log`가 먼저 호출되어 `undefined`가 출력

따라서, **비동기 함수의 처리 결과(서버의 응답 등)에 대한 후속 처리는 비동기 함수 내부에서 수행해야 한다.**
- 비동기 함수를 범용적으로 사용하기 위해 비동기 함수에 비동기 처리 결과에 대한 후속 처리를 수행하는 콜백 함수를 전달하는 것이 일반적
- 필요에 따라 비동기 처리가 성공하면 호출될 콜백 함수와 실패하면 호출될 콜백 함수를 전달

#### 콜백 헬<sup>callback hell</sup>
- 콜백 함수 호출이 중첩되어 복잡도가 높아지는 현상

```javascript
const get = (url, callback) => {
  const xhr = new XMLHttpRequest();
  xhr.open("GET", url);
  xhr.send();

  xhr.onload = () => {
    if (xhr.status === 200) {
      // 서버의 응답을 콜백 함수에 전달하면서 호출하여 응답에 대한 후속 처리
      callback(JSON.parse(xhr.response));
    } else {
      console.error(`${xhr.status} ${xhr.statusText}`);
    }
  };
};

const url = "https://jsonplaceholder.typicode.com";

// id가 1인 post의 userId 취득
get(url + "/posts/1", ({ userId }) => {
  console.log(userId);

  // post의 userId를 통해 user 정보 취득
  get(url + "/users/" + userId, (userInfo) => {
    console.log(userInfo);
  });
});
```

### 에러 처리의 한계
- 콜백 패턴의 문제점은 에러 처리가 곤란하다는 것이다.

```javascript
try {
  // 1초 후 콜백 함수가 실행되도록 타이머 설정
  setTimeout(() => { throw new Error("Error!"); }, 1000);
} catch (e) {
  // 에러를 캐치하지 못함
  console.error("캐치한 에러", e);
}
```

- **에러는 호출자<sup>caller</sup> 방향으로 전파**
  - 콜 스택 아래 방향(실행 중인 실행 컨텍스트가 푸시되기 직전에 푸시된 실행 컨텍스트 방향)으로 전파
- `setTimeout` 함수의 콜백 함수가 실행될 때 `setTimeout` 함수는 이미 콜 스택에서 제거된 상태
  - `setTimeout`의 콜백 함수를 호출한 것이 `setTimeout` 함수가 아니라는 것을 의미
- `setTimeout` 함수의 콜백 함수가 발생시킨 에러는 `catch` 블록에서 캐치되지 않는다.

## 📂 45.2 프로미스의 생성
#### `Promise`
- ES6에서 도입된 ECMAScript 사양에 정의된 표준 빌트인 객체
- `Promise` 생성자 함수를 `new` 연산자와 함께 호출하여 `Promise` 객체 생성
- `Promise` 생성자 함수는 비동기 처리를 수행할 콜백 함수 `resolve`, `reject` 함수를 인수로 전달 받음
  - 비동기 처리가 성공하면 `resolve` 함수 호출
  - 비동기 처리가 실패하면 `reject` 함수 호출

#### 비동기 처리 상태 정보
- 프로미스는 현재 비동기 처리의 진행 상태 정보를 갖는다.
  | 프로미스의 상태 정보 | 의미 | 상태 변경 조건 |
  | -------- | -------- | -------- |
  | `pending` | 비동기 처리가 아직 수행되지 않은 상태 | 프로미스가 생성된 직후 기본 상태 |
  | `fulfilled` | 비동기 처리가 수행된 상태(성공) | `resolve` 함수 호출 |
  | `rejected` | 비동기 처리가 수행된 상태(실패) | `reject` 함수 호출 |
- 생성된 직후의 프로미스는 기본적으로 `pending` 상태
- 이후 비동기 처리가 수행되면 그 결과에 따라 프로미스의 상태가 변경
  - 비동기 처리 성공 : `resolve` 함수를 호출하여 프로미스를 `fulfilled` 상태로 변경
  - 비동기 처리 실패 : `reject` 함수를 호출하여 프로미스를 `rejected` 상태로 변경
- `settled` 상태
  - 비동기 처리가 수행된 상태
  - `fulfilled` 또는 `rejected` 상태와 상관없이 `pending`이 아닌 상태
  - 프로미스는 `pending` 상태에서 `settled` 상태로 변할 수 있지만, 일단 `settled` 상태가 되면 더는 다른 상태로 변화할 수 없다.

⇒ 프로미스는 **비동기 처리 상태**와 **처리 결과**를 관리하는 객체

## 📂 45.3 프로미스의 후속 처리 메서드
- 프로미스는 후속 메서드 `then`, `catch`, `finally`를 제공
- **프로미스의 비동기 처리 상태가 변화하면 후속 처리 메서드에 인수로 전달한 콜백 함수가 선택적으로 호출된다.**
  - 후속 처리 메서드의 콜백 함수에 프로미스의 처리 결과가 인수로 전달
  - 모든 후속 처리 메서드는 프로미스를 반환하며, 비동기로 동작

### `Promise.prototype.then`
- `then` 메서드는 두 개의 콜백 함수를 인수로 전달받는다.
  - 첫 번째 콜백 함수
    - 비동기 처리가 성공했을 때 호출되는 성공 처리 콜백 함수
    - 프로미스가 `fulfilled` 상태가 되면 호출
    - 이때 콜백 함수는 프로미스의 비동기 **처리 결과**를 인수로 전달받는다.
  - 두 번째 콜백 함수
    - 비동기 처리가 실패했을 때 호출되는 실패 처리 콜백 함수
    - 프로미스가 `rejected` 상태가 되면 호출
    - 이때 콜백 함수는 프로미스의 **에러**를 인수로 전달받는다.

```javascript
new Promise(resolve => resolve('fulfilled'))
  .then(v => console.log(v), e => console.error(e)); // fulfilled

new Promise((_, reject) => reject(new Error('rejected')))
  .then(v => console.log(v), e => console.error(e)); // Error: rejected
```

### `Promise.prototype.catch`
- `catch` 메서드는 한 개의 콜백 함수를 인수로 전달받는다.
- `catch` 메서드의 콜백 함수는 프로미스가 `rejected` 상태인 경우에만 호출
- `catch` 메서드는 `then(undefined, onRejected)`과 동일하게 동작

```javascript
new Promise((_, reject) => reject(new Error('rejected')))
  .catch(e => console.error(e)); // Error: rejected
```

### `Promise.prototype.finally`
- `finally` 메서드는 한 개의 콜백 함수를 인수로 전달받는다.
- `finally` 메서드의 콜백 함수는 프로미스의 성공 또는 실패와 상관없이 무조건 한 번 호출된다.
  - 프로미스의 상태와 상관없이 공통적으로 수행해야할 처리 내용이 있을 때 유용

```javascript
new Promise(() => {})
  .finally(() => console.log('finally')); // finally
```
