# 41. 타이머

## ****41.1. 호출 스케줄링****

- 타이머 함수는 호스트 객체
- ECMAScript 사양에 정의된 빌트인 함수가 아님 → 브라우저 환경과 Node.js 환경에서 모두 전역 객체의 메서드로서 타이머 함수를 제공함
- **자바스크립트 엔진은 싱글 스레드로 동작함**
- setTimeout, setInterval은 비동기 처리 방식으로 동작

## ****41.2. 타이머 함수****

### ****41.2.1. setTimeout / clearTimeout****

- setTimeout 함수는 **타이머 id를 반환함**
- Node.js → 객체
- 브라우저 환경 → 숫자

```jsx
const timerId = setTimeout(name => console.log(`Hi, ${name}.`), 1000, 'Lee');

clearTimeout(timerId); // 타이머 아이디를 받아서 호출 스케줄링을 취소함
```

### ****41.2.2. setInterval / clearInterval****

- setTimeout과 동일하게 타이머 id를 반환함

```jsx
let count = 1;
const timeoutId = setInterval(() => {
	console.log(count);
	
	if(count++ === 5) clearInterval(timeoutId);
}, 1000);
```

## ****41.3. Debounce와 Throttle: 타이머 함수의 활용****

- 짧은 시간 간격으로 연속해서 발생하는 이벤트를 그룹화해서 **과도한 이벤트 핸들러의 호출을 방지**하는 프로그래밍 기법

### ****41.3.1. Debounce****

- 짧은 시간 간격으로 발생하는 이벤트를 그룹화해서 **마지막에 한 번만 이벤트 핸들러가 호**출되도록 한다
- 예를 들어, Ajax 요청과 같은 무거운 처리는 서버에 부담을 주므로, 사용자가 입력을 완료했을 때 한 번만 Ajax 요청을 전송하는 것이 바람직함
- ex) debonce 함수에 두 번째 인수로 전달한 딜레이 시간보다 짧은 간격으로 이벤트가 발생하면 이전 타이머를 취소하고 새로운 타이머를 재설정함
- **autocomplete UI, 버튼 중복 클릭 방지** 처리 등에 유용하게 사용됨
- ex) 네이버처럼 **자동 완성 기능**이 있는 검색창을 구현해야 한다고 가정하자. 검색 키워드에 대한 자동완성 리스트를 보여주기 위해서는 키워드를 입력할 때마다 API 요청을 해야 함. → 따라서 "naver"을 검색해야 하는 경우 5번의 API 요청을 합니다.
    - 이러한 방법은 상당히 비효율적입니다.
    - Debounce 기법을 사용하면, 함수는 5번 호출되지만 일정 시간이 지난 후 마지막 호출에서 검색 키워드에 대한 API를 요청합니다.
    - API 호출 횟수가 5번에서 1번으로 감소되므로 코드가 좀 더 효율적으로 동작합니다.
- 실무에서는 Underscore의 debounce 함수나 Lodash의 debounce 함수 사용을 권장함

### ****41.3.2. Throttle****

- 짧은 시간 간격으로 연속해서 발생하는 이벤트를 그룹화해서 **일정 시간 단위로 이벤트 핸들러가 호출되도록 호출 주기를 만듦**
- **스크롤 이벤트** 처리, **무한 스크롤 UI** 구현 등에 사용됨
- 실무에서는 Underscore의 throttle 함수나 Lodash의 throttle 함수 사용을 권장함

---

### 느낀 점

- 우테코 점심뭐먹지 미션을 진행하면서 바닐라 JS로 어떻게 렌더링과 이벤트 핸들링을 할지 고민이 많았다. 논의 결과 debounce라는 개념을 이용해서 렌더링이 2번 되는 현상을 막아주기로 결정했다.
- 예시 코드

```jsx
export const debounce = (callback: () => void) => {
  let id = -1;

  return () => {
    cancelAnimationFrame(id);

    id = requestAnimationFrame(callback);
  };
};
```

- 부모 컴포넌트에서 이벤트 한번, 자식 컴포넌트에서 이벤트 한번 이렇게 2번 렌더링이 되기 때문에 debounce 함수를 이용하며 이런 중복 렌더링을 방지해줄 수 있었다. 처음 들었을 때 재밌는 개념이라고 생각했는데, 이벤트 핸들링에서도 역시 사용되고 있어서 반갑다.
- debounce 함수는 클로저를 반환하고 있는데, 클로저가 있기 때문에 어떤 상태나 이벤트가 있었는지 JS가 기억할 수 있구나, 를 깨닫게 되었다.
- 예전에 배웠던 클로저라는 개념이 이렇게 유용하게 쓰일 수 있다는 점이 흥미롭다. 흩어져 있던 지식들이 퍼즐처럼 끼워맞춰지는 느낌? 이 느낌이 있기 때문에 배움을 지속할 수 있는 것 아닐까…