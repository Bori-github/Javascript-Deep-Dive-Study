# 26장 ES6 함수의 추가 기능

## 📂 26.1 함수의 구분

#### ES6 이전의 다양한 함수 호출

- 일반적인 함수로서 호출
- `new` 연산자와 함께 호출하여 인스턴스를 생성할 수 있는 생성자 함수로서 호출
- 객체에 바인딩되어 메서드로서 호출

⇒ 별다른 구분없이 다양한 목적으로 사용하여, 실수를 유발시킬 수 있으며 성능 면에서도 좋지 않다.

```javascript
var foo = function () {
  return 1;
};

// 일반적인 함수로서 호출
foo(); // 1

// 생성자 함수로서 호출
new foo(); // foo {}

// 메서드로서 호출
var obj = { foo: foo };
obj.foo(); // 1
```

- ES6 이전의 모든 함수는 `callable`이면서 `constructor`다.
  ⇒ 따라서 객체에 바인딩된 함수도 일반 함수로서 호출할 수 있는 것은 물론 생성자함수로서 호출할 수 있다.

```javascript
// 프로퍼티 f에 바인딩된 함수는 callable이며 constructor다.
var obj = {
  x: 10,
  f: function () {
    return this.x;
  },
};

// 프로퍼티 f에 바인딩된 함수를 메서드로서 호출
console.log(obj.f()); // 10

// 프로퍼티 f에 바인딩된 함수를 일바 ㄴ함수로서 호출
var bar = obj.f;
console.log(bar()); // undefined

// 프로퍼티 f에 바인딩된 함수를 생성자 함수로서 호출
console.log(new obj.f()); // f {}
```

- 객체에 바인딩된 함수가 `constructor`라는 것은 객체에 바인딩된 함수가 `prototype` 프로퍼티를 가지며, 프로토타입 객체도 생성한다는 것을 의미
- 함수에 전달되어 보조 함수의 역할을 수행하는 콜백 함수도 `constructor`이기 때문에 불필요한 프로토타입 객체를 생성한다.

#### ES6에서는 함수를 사용 목적에 따라 세 가지 종류로 명확히 구분

|  ES6 함수의 구분   | `constructor` | `prototype` | `super` | `argments` |
| :----------------: | :-----------: | :---------: | :-----: | :--------: |
| 일반 함수(Normal)  |      ⭕️      |     ⭕️     |   ❌    |    ⭕️     |
|   메서드(Method)   |      ❌       |     ❌      |   ⭕️   |    ⭕️     |
| 화살표 함수(Arrow) |      ❌       |     ❌      |   ❌    |     ❌     |

## 📂 26.2 메서드

- ES6 사양에서 메서드는 **메서드 축약 표현으로 정의된 함수**만을 의미한다.
- ES6 사양에서 정의한 메서드(이하 ES6 메서드)는 인스턴스를 생성할 수 없는 non-construct다.
  ⇒ ES6 메서드는 생성자 함수로서 호출할 수 없다.
- ES6 메서드는 인스턴스를 생성할 수 없으므로 prototype 프로퍼티가 없고 프로토타입도 생성하지 않는다.
- ES6 메서드는 자신을 바인딩한 객체를 가리키는 내부 슬롯 `[[HomeObject]]`를 갖는다.
  ⇒ ES6 메서드가 아닌 함수는 내부 슬롯 `[[HomeObject]]`를 갖지 않기 때문에 ES6 메서드가 아닌 함수는 `super` 키워드를 사용할 수 없다.

```javascript
const obj = {
  x: 1,
  // foo는 메서드다.
  foo() {
    return this.x;
  },
  // bar에 바인딩된 함수는 메서드가 아닌 일반 함수다.
  bar: function () {
    return this.x;
  },
};

console.log(obj.foo()); // 1
console.log(obj.bar()); // 1

// ES6 메서드는 생성자 함수로서 호출할 수 없다.
new obj.foo(); // TypeError: obj.foo is not a constructor
new obj.bar(); // bar {}

// obj.foo는 constructor가 아닌 ES6 메서드이므로 prototype 프로퍼티가 없다.
obj.foo.hasOwnProperty('prototype'); // false

// obj.bar는 constructor인 일반 함수이므로 prototype 프로퍼티가 있다.
obj.bar.hasOwnProperty('prototype'); // true
```
