# 23. 실행 컨텍스트
## 23.1 소스코드의 타입

- ECMAScript는 소스 코드를 4가지 타입으로 구분함.

| 소스코드의 타입 | 설명 |
| --- | --- |
| 전역 코드 | 전역에 존재하는 소스코드 |
| 함수 코드 | 함수 내부에 존재하는 소스코드 |
| eval 코드 | 빌트인 전역 함수인 eval 함수에 인수로 전달되어 실행되는 소스코드 |
| 모듈 코드 | 모듈 내부에 존재하는 소스코드 |
1. 전역 코드: 전역 변수를 관리하기 위해 전역 scope를 생성함, `var` 전역 변수와 함수 선언문의 전역 함수를 전역 객체의 property와 method로 바인딩함.
2. 함수 코드: 지역 scope를 생성하고 지역 변수, 매개변수, arguments 객체 관리함. 전역 scope에서 시작하는 scope chain의 일원으로 연결함. 
3. eval 코드: strict mode에서 자신만의 독자적인 scope 생성함.
4. 모듈 코드: 모듈별로 독자적인 모듈 scope를 생성함.

> 각 코드는 각자만의 실행 컨텍스트를 생성함.
> 

## 23.2 소스코드의 평가와 실행

> JS 엔진은 소스코드를 평가 및 실행 이라는 2가지 과정으로 처리함.
> 
- 소스코드의 평가: 실행 컨텍스트를 생성하고, 변수/함수 등의 선언문만 먼저 실행함. 생성된 변수/함수 식별자를 Key로, 실행 컨텍스트가 관리하는 scope에 등록함.
- 소스코드의 실행 (런타인, Runtime): 선언문을 제외한 소스코드가 순차적으로 실행함. 변수/함수의 참조 등 소스코드 실행에 필욯나 정보는 실행 컨텍스트가 관리하는 scope에 검색하여 취득함. scope의 실행 결과는 다시 실행 컨텍스트가 관리하는 scope에 등록함.
- 아래의 예시 코드를 살펴보자.

```jsx
var x = 1;

var x;
x = 1;
```

- 소스 코드 평가 과정에서 변수 선언문 `var x;` 가 먼저 실행됨.
- 변수 식별자 x는 실행 컨텍스트가 관리하는 **scope에 등록**되고 `undefined`로 초기화.
- 소스 코드 실행 과정에서 변수 할당문 `x=1;` 만 실행됨.
- x 변수에 **값을 할당**하려면 먼저 x 변수가 **선언된 변수**인지 확인.
- 실행 컨텍스트가 관리하는 **scope에 등록**되어 있는지 확인.
- 선언된 변수라면 값을 할당하고 할당 결과를 실행 컨텍스트에 등록하여 관리.

## 23.3 실행 컨텍스트의 역할

- 아래 코드 예시를 살펴보자.

```jsx
// 전역 변수 선언
const x = 1;
const y = 2;

// 함수 정의
function foo(a) {
  // 지역 변수 선언
  const x = 10;
  const y = 20;

  // 메서드 호출
  console.log(a + x + y); // 130
}

// 함수 호출
foo(100);

// 메서드 호출
```

1. **전역 코드 평가**
    1. 선언문만 먼저 실행하여 실행 컨텍스트가 관리하는 전역 scope에 등록함.
    2. var 변수와 함수 선언문의 전역 함수는 전역 객체의 property 및 메서드로 등록함.
2. **전역 코드 실행**
    1. 런타임이 시작되어 전역 코드가 순차적으로 실행됨.
    2. 전역 변수에 값이 할당되고 함수가 호출함.
    3. 함수가 호출되면 전역 코드 실행이 멈추고 해당 함수 내부로 진입됨.
3. **함수 코드 평가**
    1. **매개변수와 지역 변수 선언문**이 먼저 실행됨
    2. 실행 컨텍스트가 관리하는 지역 scope에 등록됨
    3. 함수 내부에서 지역 변수처럼 사용할 수 있는 arguments 객체가 생성되어 지역 scope에 등록됨
    4. **this 바인딩** 결정함.
4. **함수 코드 실행**
    1. 런타임이 시작되어 함수 코드가 순차적으로 실행함
    2. 매개변수와 지역 변수에 값이 할당
    3. `console.log()` 메서드 호출
    4. 식별자 console을 **scope chaining**으로 검색하여 전역 객체의 property까지 접근함.
    5. 전역 객체 중 console 객체의 log property를 검색함. (prototype chain)
    6. 인수 a, x, y를 전달하여 `console.log(a+x+y);` 실행함
5. **함수 코드 종료**
    - 함수 코드 실행이 종료되고 다시 전역 코드 실행을 재개함.
    
    > 코드가 실행되려면 scope, 식별자, 코드 실행 순서 등의 관리가 필요함.
    > 
    1. 선언된 모든 **식별자(변수, 함수, 클래스 등)**을 scope를 구분하여 등록하여 지속적으로 관리함.
    2. scope는 중첩 관계에 의해 scope chain을 형성함
    3. 현재 실행 중인 코드의 실행 순서를 변경하고 다시 되돌아올 수 있어야 함.
    - **실행 컨텍스트**
        - 소스 코드 실행에 필요한 환경을 제공.
        - 코드의 실행 결과를 실제로 관리하는 영역.
        - 식별자를 등록하고 관리하는 스코프와 코드 실행 순서 관리를 구현한 내부 메커니즘.
        - 모든 코드는 실행 컨텍스트를 통해 실행되고 관리.
        - 식별자와 스코프는 실행 컨텍스트의 렉시컬 환경에서 관리.
        - 코드 실행 순서는 **실행 컨텍스트 스택**으로 관리

## 23.4 실행 컨텍스트 스택

- 실행 컨텍스트는 **스택(stack) 자료 구조**로 관리함

> **실행 중인 실행 컨텍스트 (Running Execution Context)** : 실행 컨텍스트 스택의 최상위에 존재하는 실행 컨텍스트는 현재 실행 중인 코드의 실행 컨텍스트
> 
- 아래 코드 예시를 살펴보자.

```jsx
const x = 1;

function foo () {
  const y = 2;

  function bar () {
    const z = 3;
    console.log(x + y + z);
  }
  bar();
}

foo(); // 6
```

1. **전역 코드의 평가와 실행** : 전역 실행 컨텍스트가 생성되고, 실행 컨텍스트 스택에 푸시.
2. **foo 함수 코드의 평가와 실행** : foo 함수가 호출되어 전역 코드 실행이 중단되고, 코드의 제어권 (Control)이 foo 함수 내부로 이동. foo 함수 실행 컨텍스트가 생성되고, 실행 컨텍스트 스택에 푸시함.
3. **bar 함수 코드의 평가와 실행 :** 중첩 함수 bar가 호출되면 코드의 제어권이 bar 함수 내부로 이동. bar 함수 실행 컨텍스트가 생성되고, 실행 컨텍스트 스택에 푸시함. `console.log()`가 실행되고 bar 함수는 종료됨.
4. **foo 함수 코드로 복귀 :** 코드의 제어권은 foo 함수로 이동. bar 함수의 실행 컨텍스트는 실행 컨텍스트 스택에서 제거. foo 함수 종료.
5. **전역 코드로 복귀** : 코드의 제어권은 전역 코드로 이동함. foo 함수의 실행 컨텍스트는 실행 컨텍스트 스택에서 제거됨. 전역 코드도 종료되어 실행 컨텍스트에서 제거됨.

## 23.5 렉시컬 환경

> **식별자와 식별자에 바인딩된 값.** 상위 스코프에 대한 참조를 기록하는 자료구조.
> 
- scope와 식별자를 관리함.
1. 환경 레코드: scope에 포함된 식별자와 바인딩된 값을 관리하는 저장소
2. 외부 렉시컬 환경에 대한 참조: 해당 실행 컨텍스트를 생성한 소스코드를 포함하는 상위 코드의 렉시컬 환경에 대한 참조. 
- scope chaining을 위해 필요함.

---

### 느낀 점

- 내가 쓰는 코드가 ES6의 실행 컨텍스트로 관리되고, scope에 등록된다는 점이 흥미로웠다. 이런 문법을 그동안 몰랐어서 체계적으로 코드를 관리하지 못했던 점이 아쉬울 뿐이다ㅎㅎ..
- 규칙이 있다는 것은 프로그래밍에서 만큼은 재밌게 느껴진다. 알아가는게 즐겁고 어떻게 내 코드를 개선할 수 있는지 또다른 태스크가 주어지는 거니까..
    - 예를 들어 변수를 어떻게 관리할지(전역 또는 지역), 콜백 함수 안에 변수를 선언할지 말지 등등
- 평가→실행→종료 라는 일련의 과정이 이루어지고 있음을 배웠으며, 디버깅할 때 이를 참고할 수 있을 듯하다.