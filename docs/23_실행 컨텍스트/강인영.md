# 23. 실행 컨텍스트
## 23.1 소스코드의 타입

- ECMAScript는 소스 코드를 4가지 타입으로 구분함.

| 소스코드의 타입 | 설명 |
| --- | --- |
| 전역 코드 | 전역에 존재하는 소스코드 |
| 함수 코드 | 함수 내부에 존재하는 소스코드 |
| eval 코드 | 빌트인 전역 함수인 eval 함수에 인수로 전달되어 실행되는 소스코드 |
| 모듈 코드 | 모듈 내부에 존재하는 소스코드 |
1. 전역 코드: 전역 변수를 관리하기 위해 전역 scope를 생성함, `var` 전역 변수와 함수 선언문의 전역 함수를 전역 객체의 property와 method로 바인딩함.
2. 함수 코드: 지역 scope를 생성하고 지역 변수, 매개변수, arguments 객체 관리함. 전역 scope에서 시작하는 scope chain의 일원으로 연결함. 
3. eval 코드: strict mode에서 자신만의 독자적인 scope 생성함.
4. 모듈 코드: 모듈별로 독자적인 모듈 scope를 생성함.

> 각 코드는 각자만의 실행 컨텍스트를 생성함.
> 

## 23.2 소스코드의 평가와 실행

> JS 엔진은 소스코드를 평가 및 실행 이라는 2가지 과정으로 처리함.
> 
- 소스코드의 평가: 실행 컨텍스트를 생성하고, 변수/함수 등의 선언문만 먼저 실행함. 생성된 변수/함수 식별자를 Key로, 실행 컨텍스트가 관리하는 scope에 등록함.
- 소스코드의 실행 (런타인, Runtime): 선언문을 제외한 소스코드가 순차적으로 실행함. 변수/함수의 참조 등 소스코드 실행에 필욯나 정보는 실행 컨텍스트가 관리하는 scope에 검색하여 취득함. scope의 실행 결과는 다시 실행 컨텍스트가 관리하는 scope에 등록함.
- 아래의 예시 코드를 살펴보자.

```jsx
var x = 1;

var x;
x = 1;
```

- 소스 코드 평가 과정에서 변수 선언문 `var x;` 가 먼저 실행됨.
- 변수 식별자 x는 실행 컨텍스트가 관리하는 **scope에 등록**되고 `undefined`로 초기화.
- 소스 코드 실행 과정에서 변수 할당문 `x=1;` 만 실행됨.
- x 변수에 **값을 할당**하려면 먼저 x 변수가 **선언된 변수**인지 확인.
- 실행 컨텍스트가 관리하는 **scope에 등록**되어 있는지 확인.
- 선언된 변수라면 값을 할당하고 할당 결과를 실행 컨텍스트에 등록하여 관리.

## 23.3 실행 컨텍스트의 역할

- 아래 코드 예시를 살펴보자.

```jsx
// 전역 변수 선언
const x = 1;
const y = 2;

// 함수 정의
function foo(a) {
  // 지역 변수 선언
  const x = 10;
  const y = 20;

  // 메서드 호출
  console.log(a + x + y); // 130
}

// 함수 호출
foo(100);

// 메서드 호출
```

1. **전역 코드 평가**
    1. 선언문만 먼저 실행하여 실행 컨텍스트가 관리하는 전역 scope에 등록함.
    2. var 변수와 함수 선언문의 전역 함수는 전역 객체의 property 및 메서드로 등록함.
2. **전역 코드 실행**
    1. 런타임이 시작되어 전역 코드가 순차적으로 실행됨.
    2. 전역 변수에 값이 할당되고 함수가 호출함.
    3. 함수가 호출되면 전역 코드 실행이 멈추고 해당 함수 내부로 진입됨.
3. **함수 코드 평가**
    1. **매개변수와 지역 변수 선언문**이 먼저 실행됨
    2. 실행 컨텍스트가 관리하는 지역 scope에 등록됨
    3. 함수 내부에서 지역 변수처럼 사용할 수 있는 arguments 객체가 생성되어 지역 scope에 등록됨
    4. **this 바인딩** 결정함.
4. **함수 코드 실행**
    1. 런타임이 시작되어 함수 코드가 순차적으로 실행함
    2. 매개변수와 지역 변수에 값이 할당
    3. `console.log()` 메서드 호출
    4. 식별자 console을 **scope chaining**으로 검색하여 전역 객체의 property까지 접근함.
    5. 전역 객체 중 console 객체의 log property를 검색함. (prototype chain)
    6. 인수 a, x, y를 전달하여 `console.log(a+x+y);` 실행함
5. **함수 코드 종료**
    - 함수 코드 실행이 종료되고 다시 전역 코드 실행을 재개함.
    
    > 코드가 실행되려면 scope, 식별자, 코드 실행 순서 등의 관리가 필요함.
    > 
    1. 선언된 모든 **식별자(변수, 함수, 클래스 등)**을 scope를 구분하여 등록하여 지속적으로 관리함.
    2. scope는 중첩 관계에 의해 scope chain을 형성함
    3. 현재 실행 중인 코드의 실행 순서를 변경하고 다시 되돌아올 수 있어야 함.
    - **실행 컨텍스트**
        - 소스 코드 실행에 필요한 환경을 제공.
        - 코드의 실행 결과를 실제로 관리하는 영역.
        - 식별자를 등록하고 관리하는 스코프와 코드 실행 순서 관리를 구현한 내부 메커니즘.
        - 모든 코드는 실행 컨텍스트를 통해 실행되고 관리.
        - 식별자와 스코프는 실행 컨텍스트의 렉시컬 환경에서 관리.
        - 코드 실행 순서는 **실행 컨텍스트 스택**으로 관리

## 23.4 실행 컨텍스트 스택

- 실행 컨텍스트는 **스택(stack) 자료 구조**로 관리함

> **실행 중인 실행 컨텍스트 (Running Execution Context)** : 실행 컨텍스트 스택의 최상위에 존재하는 실행 컨텍스트는 현재 실행 중인 코드의 실행 컨텍스트
> 
- 아래 코드 예시를 살펴보자.

```jsx
const x = 1;

function foo () {
  const y = 2;

  function bar () {
    const z = 3;
    console.log(x + y + z);
  }
  bar();
}

foo(); // 6
```

1. **전역 코드의 평가와 실행** : 전역 실행 컨텍스트가 생성되고, 실행 컨텍스트 스택에 푸시.
2. **foo 함수 코드의 평가와 실행** : foo 함수가 호출되어 전역 코드 실행이 중단되고, 코드의 제어권 (Control)이 foo 함수 내부로 이동. foo 함수 실행 컨텍스트가 생성되고, 실행 컨텍스트 스택에 푸시함.
3. **bar 함수 코드의 평가와 실행 :** 중첩 함수 bar가 호출되면 코드의 제어권이 bar 함수 내부로 이동. bar 함수 실행 컨텍스트가 생성되고, 실행 컨텍스트 스택에 푸시함. `console.log()`가 실행되고 bar 함수는 종료됨.
4. **foo 함수 코드로 복귀 :** 코드의 제어권은 foo 함수로 이동. bar 함수의 실행 컨텍스트는 실행 컨텍스트 스택에서 제거. foo 함수 종료.
5. **전역 코드로 복귀** : 코드의 제어권은 전역 코드로 이동함. foo 함수의 실행 컨텍스트는 실행 컨텍스트 스택에서 제거됨. 전역 코드도 종료되어 실행 컨텍스트에서 제거됨.

## 23.5 렉시컬 환경

> **식별자와 식별자에 바인딩된 값.** 상위 스코프에 대한 참조를 기록하는 자료구조.
> 
- scope와 식별자를 관리함.
1. 환경 레코드: scope에 포함된 식별자와 바인딩된 값을 관리하는 저장소
2. 외부 렉시컬 환경에 대한 참조: 해당 실행 컨텍스트를 생성한 소스코드를 포함하는 상위 코드의 렉시컬 환경에 대한 참조. 
- scope chaining을 위해 필요함.

## 23.6 실행 컨텍스트의 생성과 식별자 검색 과정

- 아래 예시를 통해 실행 컨텍스트의 생성 및 식별자 검색 과정을 알아보자.

```jsx
var x = 1;
const y = 2;

function foo (a) {
  var x = 3;
  const y = 4;

  function bar (b) {
    const z = 5;
    console.log(a + b + x + y + z);
}
  bar(10);
}

foo(20); // 42
```

### 23.6.1 전역 객체 생성

- **전역 코드가 평가되기** 이전에 생성됨.
- 빌트인 전역 프로퍼티, 빌트인 전역 함수, 표준 빌트인 객체, Web API 등이 포함됨.
- `Object.prototye`을 상속받는 자식 객체

### 23.6.2 전역 코드 평가

1. **전역 실행 컨텍스트 생성**: 비어있는 전역 실행 컨텍스트가 생성되어 실행 컨텍스트 스택에 추가됨.
2. **전역 렉시컬 환경 생성**: 전역 렉시컬 환경이 생성되어 전역 실행 컨텍스트에 바인딩됨. 렉시컬 환경은 환경 레코드와 외부 렉시컬 환경에 대한 참조로 구성됨.
    - **2.1. 전역 환경 레코드 생성**
    
    `var` 전역 변수, 함수 선언문의 전역 함수, 빌트인 전역 프로퍼티, 빌트인 전역 객체 등은 **객체 환경 레코드 (Object Environment Record)**에 저장.
    
    `let, const` 전역 변수는 **선언적 환경 레코드 (Declarative Environment Record)**에 저장
    
    - 객체 환경 레코드
        
        객체 환경 레코드는 **전역 객체인 BindingObject**와 연결.
        
        **BindingObject**는 전역 환경 레코드의 객체 환경 레코드에 연결되어있음. `var` 전역 변수와 함수 선언문의 전역 함수는 BindingObject를 통해 전역 객체에 저장된 후 암묵적으로 undefined로 초기화. **(변수 호이스팅이 발생하는 원인)**
        
    - 선언적 환경 레코드
        
        `let, const` 전역 변수는 선언적 환경 레코드에 등록.
        
        전역 객체에 저장되지 않기 때문에 **전역 객체의 프로퍼티로 참조가 불가능**. 선언과 초기화가 분리되어 진행. 이 과정을 **일시적 사각지대 (Temporal Dead Zone, TDZ)** 라고 한다.
        
    - **2.2. this 바인딩**: 전역 환경 레코드의 `[[GlobalThisValue]]` 내부 슬롯에 this가 바인딩되고 전역 객체를 가리킴. 따라서 전역 공간에서 this를 참조하면 전역 객체가 반환됨.
    - **2.3. 외부 렉시컬 환경에 대한 참조 결정**: 현재 평가 중인 소스 코드의 외부 렉시컬 환경, 즉 상위 scope를 참조함.

### 23.6.3 전역 코드 실행

```jsx
var x = 1;
const y = 2;

function foo (a) {
  var x = 3;
  const y = 4;

  function bar (b) {
    const z = 5;
    console.log(a + b + x + y + z);
}
  bar(10);
}

foo(20);
```

- 변수 또는 함수를 실행하기 위해 현재의 실행 컨텍스트에서 식별자를 검색함. (식별자 결정, Identifier Resolution)

### 23.6.4 foo 함수 코드 평가

```jsx
var x = 1;
const y = 2;

function foo (a) {
  var x = 3;
  const y = 4;

  function bar (b) {
    const z = 5;
    console.log(a + b + x + y + z);
}
  bar(10);
}

foo(20); // ← 호출 직전
```

전역 코드 실행을 중단하고 **foo 함수 내부**로 이동.

1. **함수 실행 컨텍스트 생성:** 실행 컨텍스트 스택에 Push
2. **함수 렉시컬 환경 생성**.
    - **2.1. 함수 환경 레코드 생성**: 매개변수, arguments 객체, 함수 내부의 지역 변수 및 중첩 함수가 등록됨.
    - **2.2. this 바인딩**: 함수 환경 레코드에 this를 바인딩, 함수가 호출되는 위치에 따라 this에 바인딩되는 객체가 달라짐. 함수 foo는 전역 공간에서 호출되었기 때문에 **전역 객체가 바인딩**됨.
    - **2.3. 외부 렉시컬 환경에 대한 참조 결정**: foo 함수의 상위 scope를 다루는 실행 컨텍스트의 렉시컬 환경과 연결됨. (함수 foo는 전역 객체와 연결됨.)

### 23.6.5 foo 함수 코드 실행

- foo 함수 실행 컨텍스트의 렉시컬 환경에서 **식별자를 검색**함. 검색된 식별자에 값을 바인딩.

### 23.6.6 bar 함수 코드 평가

```jsx
var x = 1;
const y = 2;

function foo (a) {
  var x = 3;
  const y = 4;

  function bar (b) {
    const z = 5;
    console.log(a + b + x + y + z);
  }
  bar(10); // ← 호출 직전
}

foo(20);
```

- bar 함수 평가 시작, 실행 컨텍스트가 생성되고 스택에 추가됨
- foo 함수와 동일하게 bar 렉시컬 환경을 만듦 → 환경 레코드 생성 → this 바인딩 → 외부 렉시컬 환경 참조를 할당함.

### 23.6.7 bar 함수 코드 실행

- 런타임 시작 → **변수 z**에 매개 변수 값 할당함 → `console.log()` 실행을 위해 scope chaining을 통해 전역 객체에서 console 객체를 검색. → console 객체의 log 메서드를 검색. → `console.log`에 a + b + x + y+ z 값을 전달하여 최종 실행.

### 23.6.8 bar 함수 코드 실행 종료

- 실행 컨텍스트 스택에서 pop되어 제거되고 foo 함수 실행 컨텍스트가 다시 실행.

### 23.6.9 foo 함수 코드 실행 종료

- 실행 컨텍스트 스택에서 pop되어 제거되고 전역 실행 컨텍스트가 다시 실행.

### 23.6.10 전역 함수 실행 종료

- 실행 컨텍스트 스택에서 pop되어 제거되고 실행 컨텍스트 스택은 빈 공간이 됨.

## 23.7 실행 컨텍스트와 블록 레벨 스코프

```jsx
let x = 1;

if (true) {
  let x = 10;
  console.log(x); // 10
}

console.log(x); // 1
```

- if 문, for 문 등의 블록이 실행되면, 이 블록 만을 위한 **선언적 환경 레코드**를 갖는 렉시컬 환경이 생성되고 **기존의 렉시컬 환경을 교체함**.
- 블록이 종료되면 **다시 이전의 렉시컬 환경으로 복귀**.

### 🔎 참고사항

- 식별자란?
    - **자바스크립트에서 이름을 붙일 때 사용하는 단어**. 식별자의 예로는 **변수명**과 **함수명**이 있음.
- 호이스팅이란?
    - JavaScript에서 **호이스팅**(hoisting)이란, 인터프리터가 변수와 함수의 메모리 공간을 선언 전에 미리 할당하는 것을 의미함. `var`로 선언한 변수의 경우 호이스팅 시 `undefined`로 변수를 초기화함. 반면 `let`과 `const`로 선언한 변수의 경우 **호이스팅 시 변수를 초기화하지 않음**.
---

### 느낀 점

- 내가 쓰는 코드가 ES6의 실행 컨텍스트로 관리되고, scope에 등록된다는 점이 흥미로웠다. 이런 문법을 그동안 몰랐어서 체계적으로 코드를 관리하지 못했던 점이 아쉬울 뿐이다ㅎㅎ..
- 규칙이 있다는 것은 프로그래밍에서 만큼은 재밌게 느껴진다. 알아가는게 즐겁고 어떻게 내 코드를 개선할 수 있는지 또다른 태스크가 주어지는 거니까..
    - 예를 들어 변수를 어떻게 관리할지(전역 또는 지역), 콜백 함수 안에 변수를 선언할지 말지 등등
- 평가→실행→종료 라는 일련의 과정이 이루어지고 있음을 배웠으며, 디버깅할 때 이를 참고할 수 있을 듯하다.
- 예를 들어 여러 함수에서 쓰인다는 이유로 전역 객체를 쓰고자 한다면, 객체의 생성 시점과 각 함수가 실행되는 시점을 잘 고려해야 할 것이다. 만약 전역 객체가 필요한 특정 함수를 실행하였는데 전역 객체에 아무런 값이 할당되어 있지 않다면, 원하는 대로 프로그램이 실행되지 않기 때문이다.