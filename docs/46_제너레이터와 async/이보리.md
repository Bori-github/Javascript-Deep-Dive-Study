# 46장 제너레이터와 async/await

## 📂 46.1 제너레이터란?
#### 제너레이터<sup>generator</sup>
- ES6에 도입
- 코드 블록의 실행을 일시 중지했다가 필요한 시점에 재개할 수 있는 특수한 함수

#### 제너레이터와 일반함수의 차이
- 제너레이터 함수는 함수 호출자에게 제어권을 양도할 수 있다.
  - 제너레이터 함수는 함수 실행을 함수 호출자가 제어할 수 있다. 즉, **함수의 제어권을 함수가 독점하는 것이 아니라 함수 호출자에게 양도<sup>yield</sup>할 수 있다**
  - 일반 함수를 호출하면 제어권이 함수에게 넘어가고 함수 코드를 일괄 실행하여 함수 호출자는 함수를 호출한 이후 함수 실행을 제어할 수 없다.
- 제너레이터 함수는 함수 호출자와 함수의 상태를 주고받을 수 있다.
  - 제너레이터 함수는 **함수 호출자에게 상태를 전달할 수 있고 함수 호출자로부터 상태를 전달받을 수 있다.**
  - 일반 함수를 호출하면 매개변수를 통해 함수 외부에서 값을 주입받고 함수 코드를 일괄 실행하여 결과값을 함수 외부로 반환한다. 즉, 함수가 실행되고 있는 동안 함수 외부에서 함수 내부로 값을 전달하여 함수의 상태를 변경할 수 없다.
- 제너레이터 함수를 호출하면 제너레이터 객체를 반환한다.
  - 제너레이터 함수를 호출하면 함수 코드를 실행하는 것이 아니라 **이터러블이면서 동시에 이터레이터인 제너레이터 객체를 반환**
  - 일반 함수를 호출하면 함수 코드를 일괄 실행하고 값을 반환

## 📂 46.2 제너레이터 함수의 정의
- 제너레이터 함수는 `function` 키워드로 선언하고, 하나 이상의 `yeild` 표현식을 포함한다.
  - 애스터리스크(`*`)의 위치는 `function` 키워드와 함수 이름 사이라면 어디든지 상관없지만 일관성 유지를 위해 `function` 키워드 바로 뒤에 붙이는 것을 권장
  - 제너레이터 함수는 화살표 함수로 정의할 수 없다.
  - 제너레이터 함수는 `new` 연산자와 함께 생성자 함수를 호출할 수 없다.
- 나머지는 일반 함수를 정의하는 방법과 같다.

```javascript
// 제너레이터 함수 선언문
function* genDecFunc() {
  yield 1;
}

// 제너레이터 함수 표현식
const genExpFunc = function* () {
  yield 1;
}

// 제너레이터 메서드
const obj = {
  * genObjMethod() {
    yield 1;
  }
}

// 제너레이터 클래스 메서드
class MyClass {
  * genClsMethod() {
    yield 1;
  }
}
```

## 📂 46.3 제너레이터 객체
- 제너레이터 함수를 호출하면 제너레이터 객체를 생성해 반환
- 제너레이터 객체는 이터러블이면서 동시에 이터레이터다.
  - `Symbol.iterator` 메서드를 상속받아 이터러블
  - `value`, `done` 프로퍼티를 갖는 이터레이터 리절트 객체를 반환하는 `next` 메서드를 소유하는 이터레이터
  - `next` 메서드를 가지는 이터레이터이므로 `Symbol.iterator` 메서드를 호출해서 별도로 이터레이터를 생성할 필요없다.

```javascript
// 제너레이터 함수
function* genFunc() {
  yield 1;
  yield 2;
  yield 3;
}

// 제너레이터 함수를 호출하면 제너레이터 객체를 반환
const generator = genFunc();

// 이터러블 : Symbol.iterator 메서드를 직접 구현하거나 프로토타입 체인을 통해 상속받은 객체
console.log(Symbol.iterator in generator); // true
// 이터레이터는 next 메서드를 가진다.
console.log('next' in generator); // true
```

#### 제너레이터 객체는 `next` 메서드가지면서, 이터레이터에 없는 `return`, `throw` 메서드를 갖는다.
- `next` 메서드 호출
  - 제너레이터 함수의 `yield` 표현식까지 코드 블록을 실행
  - `yield`된 값을 `value` 프로퍼티 값으로, `false`를 `done` 프로퍼티 값으로 갖는 이터레이터 리절트 객체를 반환
- `return` 메서드 호출
  - 인수로 전달받은 값을 `value` 프로퍼티 값으로, `true`를 `done` 프로퍼티 값으로 갖는 이터레이터 리절트 객체를 반환
- `throw` 메서드 호출
  - 인수로 전달받은 애러를 발생시키고 `undefined`를 `value` 프로퍼티 값으로, `true`를 `done` 프로퍼티 값으로 갖는 이터레이터 리절트 객체를 반환

```javascript
function* genFunc() {
  try {
    yield 1;
    yield 2;
    yield 3;
  } catch (e) {
    console.error(e);
  }
}

const generator = genFunc();

console.log(generator.next()); // {value: 1, done: false}
console.log(generator.return('End!')); // {value: 'End!', done: true}
console.log(generator.throw('Error!')); // {value: undefined, done: true}
```

## 📂 46.4 제너레이터의 일시 중지와 재개
- 제너레이터는 `yield` 키워드와 `next` 메서드를 통해 실행을 일시 중지 했다가 필요한 시점에 다시 재개

#### `yield` 키워드
- 제너레이터 함수의 실행을 일시 중지 시키거나 `yield` 키워드 뒤에 오는 표현식의 평가 결과를 제너레이터 함수 호출자에게 반환

#### `next` 메서드
- 제너레이터 객체의 **`next` 메서드를 호출하면 `yield` 표현식까지 실행되고 일시 중지<sup>suspend</sup>** 된다.
  - 이때 함수의 제어권이 호출자로 양도된다.
  - 이후 필요한 시점에 호출자가 다시 `next` 메서드를 호출하면 일시 중지된 코드부터 실행을 재개<sup>resume</sup>하기 시작
  - 다음 `yield` 표현식까지 실행되고 또 다시 일시 중지된다.
- `next` 메서드는 `value`, `done` 프로퍼티를 갖는 이터레이터 리절트 객체를 반환
  - `value` 프로퍼티 : **`yield` 표현식에서 `yield`된 값(`yield` 키워드 뒤의 값)이 할당**
  - `done` 프로퍼티:
    - **제너레이터 함수가 끝까지 실행되었는지 나타내는 불리언 값이 할당**
    - 제너레이터 함수가 끝까지 실행되었다면 `done` 프로퍼티에 `true` 할당
- 제너레이터 객체의 `next` 메서드에는 인수를 전달 가능
  - `next` 메서드에 전달된 인수는 제너레이터 함수의 `yield` 표현식을 할당받는 변수에 할당
  - `yield` 표현식을 할당받은 변수에 `yield` 표현식의 평가 결과가 할당되지 않는 것에 조의

```javascript
function* genFunc() {
  // yield된 값 1은 value 프로퍼티에 할당
  // x 변수의 값은 next 메서드가 두 번째 호출될 때 결정됨
  const x = yield 1;

  // 두 번째 next 메서드를 호출할 때 전달한 인수는 첫 번째 yield 표현식을 할당받는 x 변수에 할당
  // 즉, const x = yield 1;은 두 번째 next 메서드를 호출했을 때 완료됨
  const y = yield (x + 10);

  // 세 번째 next 메서드를 호출하면 함수 끝까지 실행됨
  // 이때 제너레이터 함수의 반환값 x + y는 value 프로퍼티에 할당
  // 일반적으로 제너레이터의 반환값은 의미가 없음
  // return은 종료의 의미로만 사용
  return x + y;
}

const generator = genFunc(0);

let res = generator.next();
console.log(res); // {value: 1, done: false}

res = generator.next(10);
console.log(res); // {value: 20, done: false}

res = generator.next(20);
console.log(res); // {value: 30, done: true}
```
