# 12. 함수

## 12.1 함수란?

### 함수
![image](https://user-images.githubusercontent.com/72698829/208993024-7aad7902-3385-4aa3-8b4d-cd48ca856f06.png)

- 일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것
- 함수 내부로 입력을 전달 받는 변수를 매개변수, 입력은 인수, 출력을 반환 값이라 함
- 함수는 함수 정의를 통해 생성
- 인수를 매개변수를 통해 함수에 전달하면서 함수의 실행을 명시적으로 지시하는 것을 함수 호출이라 함

## 12.2 함수를 사용하는 이유

### 함수를 사용하는 이유

- 함수는 몇 번이든 호출할 수 있으므로 코드의 재사용이라는 측면에서 유리
- 함수의 이름으로 함수의 내부 코드를 이해하지 않고도 함수의 역할을 파악할 수 있게 도와 코드의 가독성 향상

## 12.3 함수 리터럴

### 함수 리터럴

```jsx
// 변수에 함수 리터럴을 할당
var f = function add(x,y) {
	return x + y;
};
```

- 함수 리터럴은 함수 이름, 매개변수 목록, 함수 몸체로 구성되어 있음
- 함수는 객체이지만 일반 객체와 다름
- 일반 객체는 호출할 수 없지만 함수는 호출할 수 있음

## 12.4 함수 정의

### 함수 정의 방식

![image](https://user-images.githubusercontent.com/72698829/208993058-c1745eaf-2dc2-43ee-ab1a-0aea08ddfe6c.png)
### 함수 선언문

![image](https://user-images.githubusercontent.com/72698829/208993110-f2d9a64f-407b-4c5a-893b-c55a6da8d1ff.png)

```jsx
function foo() { console.log('foo') }

foo(); // foo
```

- foo는 자바스크립트 엔진이 암묵적으로 생성한 식별자로 함수 선언문으로 정의된 함수는 foo라는 이름으로 호출 가능
- 자바스크립트 엔진은 생성된 함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고, 거기에 함수 객체를 할당함

### 함수 선언문과 식별자
![image](https://user-images.githubusercontent.com/72698829/208993132-9ad94469-8694-4ae2-9165-e09f9cf559b1.png)

- 함수는 함수 이름으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출됨

### 함수 표현식

```jsx
// 함수 표현식의 함수 리터럴은 함수 이름 생략 
var add = function (x,y) {
 	return x + y;
 };
```

```jsx
var add = function foo (x,y) {
	return x + y;
};

// 함수 객체를 가리키는 식별자로 호출
console.log(add(2,5)); // 7

console.log(foo(2,5)); // ReferenceError: foo is not defined
```

- 자바스크립트의 함수는 일급 객체로 함수 리터럴로 생성한 함수 객체를 변수에 할당할 수 있음
- 함수 표현식의 함수 리터럴은 함수 이름을 생략하는 것이 일반적

### 함수 생성 시점과 함수 호이스팅

```jsx
console.log(add(2, 5)); // 7
console.log(sub(2, 5)); // TypeError: sub is not a function

// 함수 선언문
function add(x, y) {
	return x+y;
}

// 함수 표현식
var sub = function (x, y) {
	reutnr x - y;
};
```

- 함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 함수 호이스팅이라 함
- 함수 선언문으로 정의한 함수는 함수 선언문 이전에 호출 가능
- 함수 표현식으로 정의한 함수는 함수 표현식 이전에 호출 불가
- 함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수의 생성 시점이 다르기 때문
- 함수 표현식으로 함수를 정의하면 함수 호이스팅이 발생하지 않고 변수 호이스팅이 발생

### Function 생성자 함수

```jsx
var add = new Function('x', 'y', 'return x + y');

console.log(add(2, 5)); // 7
```

### 화살표 함수

```jsx
const add = (x,y) => x + y;

console.log(add(2, 5)); // 7
```

- ES6에서 도입되었고 화살표 함수는 항상 익명 함수로 정의
- 기존의 함수보다 표현만 간략한 것이 아니라 내부 동작 또한 간략화되어 있음
- 생성자 함수로 사용할 수 없음
- 기존 함수와 this 바인딩 방식이 다름
- prototype 프로퍼티가 없고 arguments 객체를 생성하지 않음

## 12.6 참조에 의한 전달과 외부 상태의 변경

- 생략

## 12.7 다양한 함수의 형태

### 즉시 실행 함수

- 함수 정의와 동시에 호출되는 함수

### 재귀 함수

- 자기 자신을 호출하는 것을 수행하는 함수

### 중첩 함수

- 함수 내부에 정의된 함수

### 콜백 함수

- 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수
- 매개변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수를 고차 함수라고 함
- 고차 함수는 콜백 함수를 자신의 일부분으로 합성함

### 순수 함수와 비순수 함수

- 어떤 외부 상태에 의존하지도 않고 변경하지도 않는, 즉 부수 효과가 없는 함수를 순수함수라고 함
- 외부 상태에 의존하거나 외부 상태를 변경하는, 즉 부수 효과가 있는 함수를 비순수 함수라고 함

# ✨정리

## 함수 정의 방식

![image](https://user-images.githubusercontent.com/72698829/208993070-8918c567-84e2-4aa2-9644-d57087a129c2.png)

## 함수 호출
![image](https://user-images.githubusercontent.com/72698829/208993151-07e22127-b5c4-4bfa-83d0-1b61423ecd6b.png)

함수는 함수 이름으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출된다

## 함수 호이스팅

함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 함수 호이스팅이라 한다. 

함수 선언문으로 정의한 함수는 함수 선언문 이전에 호출 가능하고 함수 표현식으로 정의한 함수는 함수 표현식 이전에 호출 불가하다. 함수 표현식으로 함수를 정의하면 함수 호이스팅이 발생하지 않고 변수 호이스팅이 발생한다.

## 화살표 함수

내부 동작이 간략화 되어 있고기존 함수와 this 바인딩 방식이 다르다.

## 콜백 함수

함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수이다.
