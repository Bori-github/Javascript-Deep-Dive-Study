# 15장 `let`, `const` 키워드와 블록 레벨 스코프

## 📂 15.1 `var` 키워드로 선언한 변수의 문제점

ES5까지 변수를 선언할 수 있는 유일한 방법은 `var` 키워드를 사용하는 것

#### 변수 중복 선언 허용

- `var` 키워드로 선언한 변수는 중복 선언이 가능
  ⇒ 만약 동일한 이름의 변수가 이미 선언되어 있는 것을 모르고 중복 선언한다면 먼저 선언된 변수 값이 변경되는 부작용 발생

#### 함수 레벨 스코프

- `var` 키워드로 선언한 변수는 함수의 코드 블록만을 지역 스코프로 인정
  ⇒ 함수 외부에서 `var` 키워드로 선언한 변수는 코드 블록 내에서 선언해도 모두 전역 변수가 된다.

#### 변수 호이스팅

- 변수 호이스팅에 의해 `var` 키워드로 선언한 변수는 변수 선언문 이전에 참조 가능
  ⇒ 변수 선언문 이전에 변수를 참조하는 것은 변수 호이스팅에 의해 에러를 발생시키지 않지만 프로그램의 흐름에 맞지 않고 가독성을 떨어뜨리며 오류를 발생시킬 수 있다.

## 📂 15.2 `let` 키워드

`var` 키워드의 단점을 보완하기 위해 ES6에서는 새로운 변수 선언 키워드인 `let`과 `const`를 도입

#### 변수 중복 선언 금지

- `let` 키워드로 이름이 같은 변수를 중복 선언하면 문법 에러<sup>SyntaxError</sup> 발생

#### 블록 레벨 스코프

- `let` 키워드로 선언한 변수는 모든 코드 블록(함수, `if`문, `for`문, `while`문, `try/catch`문 등)을 지역 스코프로 인정하는 블록 레벨 스코프<sup>block-level scope</sup>를 따른다.

#### 변수 호이스팅

- `let` 키워드로 선언한 변수는 변수 호이스팅이 발생하지 않는 것처럼 동작
- `var` 키워드로 선언한 변수는 런타임 이전에 자바스크립트 엔진에 의해 암묵적으로 선언 단계와 초기화 단계가 한 번에 진행
- `let` 키워드로 선언한 변수는 런타임 이전에 자바스크립트 엔진에 의해 암묵적으로 선언 단계가 먼저 실행되고, 초기화 단계는 변수 선언문에 도달했을 때 실행
  ⇒ `let` 키워드로 선언한 변수는 변수 선언문 이전에 참조하면 **참조 에러(ReferenceError) 발생**
- `let` 키워드로 선언한 변수는 스코프 시작 지점부터 초기화 단계 시작 지점(변수 선언문)까지 변수를 참조할 수 없다.
  ⇒ 스코프의 시작 지점부터 초기화 시작 지점까지 변수를 참조할 수 없는 구간을 **일시적 사각지대<sup>Temporal Dead</sup>** 라고 부른다.

![](https://i.imgur.com/NUrWNjn.png)

- 자바스크립트는 ES6에 도입된 **모든 선언(`var`, `let`, `const`, `function`, `function*`, `class등`)을 호이스팅** 한다. 단, ES6에 도입된 let, const, class를 사용한 선언문은 호이스팅이 발생하지 않는 것처럼 동작

```javascript
let foo = 1; // 전역 변수

{
  console.log(foo); // ReferenceError: Cannot access 'foo' before initialization
  let foo = 2; // 지역 변수
}
```

#### 전역 객체와 `let`

- `let` 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 아니다.
  - `let` 전역 변수는 보이지 않는 개념적인 블록(전역 렉시컬 환경의 선언적 환경 레코드) 내에 존재

## 📂 15.3 `const` 키워드

- `const` 키워드는 상수<sup>constant</sup>를 선언하기 위해 사용
  - 하지만 반드시 상수만을 사용하지는 않는다.
- `const` 키워드의 특징은 `let` 키워드와 대부분 동일

#### 선언과 초기화

- `const` 키워드로 선언한 변수는 반드시 **선언과 동시에 초기화**해야 한다.
  ⇒ 그렇지 않으면 문법 에러 발생

```javascript
const foo; // SyntaxError: Missing initializer in const declaration
```

- `const` 키워드로 선언한 변수도 블록 레벨 스코프를 가지며, 변수 호이스팅이 발생하지 않는 것처럼 동작

#### 재할당 금지

```javascript
const foo = 1;
foo = 2; // TypeError: Assignment to constant variable.
```

#### 상수

- 상수 : 재할당이 금지된 변수
- `const` 키워드로 선언된 변수에 원시 값을 할당한 경우 원시 값은 변경할 수 없는 값이고, `const` 키워드에 의해 재할당이 금지되므로 할당된 값을 변셩할 수 있는 방법은 없다.
- 상수의 이름은 대문자로 선언해 상수임을 명확히 나타낸다.

#### `const` 키워드와 객체

- `const` 키워드로 선언된 변수에 객체를 할당한 경우 값을 변경할 수 있다.
- `const` 키워드는 재할당을 금지할 뿐 "불변"을 의미하지 않는다.

## 📂 15.4 `var` vs `let` vs `const`

- ES6를 사용한다면 `var` 키워드는 사용하지 않는다.
- 재할당이 필요한 경우에 한정해 let 키워드 사용. 이때 변수의 스코프는 최대한 좁게 만든다.
- 변경이 발생하지 않고 읽기 전용으로 사용하는(재할당이 필요 없는 상수) 원시값과 객체에는 const 키워드를 사용. const 키워드는 재할당을 금지하므로 `var`, `let` 키워드 보다 안전하다
